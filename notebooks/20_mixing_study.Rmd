# Mixing study

In this chapter, we will use single cell data from [@Schelker2017] to create simulated bulk RNAseq samples 
of which we know the true cell proportions. We futher use these samples to benchmark the performance of different recently published immune deconvolution tools. 

## Average fraction of tumour cells
To obtain representatitive simulated samples, we are interested in the average fraction of tumour cells vs immune cells in a mixture. 

```{r, results='hold'}
cell_type_table = pData(single_cell_schelker$eset) %>%
  filter(source %in% c("melanoma", "ascites")) %>%
  mutate(sample=paste(source, donor, sep="_")) %>% 
  group_by(source, sample, cell_type) %>% 
  summarise(n=n()) %>%
  mutate(freq=n/sum(n))

ggplot(cell_type_table, aes(x=sample, y=freq)) +
  geom_bar(aes(fill=cell_type), stat="identity") + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  scale_fill_manual(values=color_scales$cell_types)


cancer_cells = cell_type_table %>% 
  filter(cell_type %in% cell_types$cancer) 


cancer_cell_param = MASS::fitdistr(cancer_cells$freq, "normal")
```

The mean cancer fraction is `r cancer_cell_param$estimate[1]`Â±`r cancer_cell_param$estimate[2]`. 


## Create simulated bulk tissues
The fractions of a sample are randomly assigned in the following procedure: 

1. Draw a random tumour cell content from the distribution fitted above
2. The first half of the samples will use melanoma cells, the second half ovarian cancer cells. 
3. Assign the remaining fraction (=not cancer cells)  randomly to the remaining cell types (`r cell_types$available`)

```{r}
set.seed(42)

is_melanoma = c(rep(TRUE, 50), rep(FALSE, 50))

cell_fractions = lapply(is_melanoma, function(melanoma) {
  cancer_fraction = rnorm(1, mean=cancer_cell_param$estimate[1], sd=cancer_cell_param$estimate[2])
  cancer_fraction = ifelse(cancer_fraction < 0, 0, cancer_fraction)
  cancer_fraction = ifelse(cancer_fraction > 1, 1, cancer_fraction)
  
  # associate fraction randomly ot Melanoma or Ovarian
  if(melanoma) {
    cancer_fractions = list(cancer_fraction, 0)
  } else {
    cancer_fractions = list(0, cancer_fraction)
  }
  names(cancer_fractions) = cell_types$cancer
  
  # compute random fractions for other cells
  use_cell_types = c(cell_types$immune_cells, cell_types$other)
  remaining_fraction = 1 - cancer_fraction
  rnd = sample(0:100, length(use_cell_types), TRUE)
  tmp_fractions = (remaining_fraction * rnd) / sum(rnd)
  names(tmp_fractions) = use_cell_types
  
  c(cancer_fractions, tmp_fractions)
}) %>% bind_rows()

testthat::test_that("all fractions sum up to 1", expect_equal(apply(cell_fractions, 1, sum), rep(1, 100)))
```


```{r, cache=TRUE}
set.seed(42)
bulk_eset = make_bulk_eset(eset=single_cell_schelker$eset, cell_fractions = cell_fractions, n_cells=500)
```


## Run the deconvolution
We first run all methods that are integrated in the `immune_deconvolution_methods` are package automatically in a loop. 
```{r, cache=TRUE}
all_results = foreach(method=immunedeconv::deconvolution_methods,
                      .final = function(x) {setNames(x, immunedeconv::deconvolution_methods)}) %dopar% {
  deconvolute(bulk_eset, method, column="gene_symbol")
}
```

### run TIMER
TIMER [@TIMER2016] is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. 

We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. 

```{r, cache=TRUE, message=FALSE}
eset_mat = eset_to_matrix(bulk_eset, "gene_symbol")
immunedeconv::export_for_timer(eset_mat[,is_melanoma], path="../results/timer_input_melanoma.tsv")
immunedeconv::export_for_timer(eset_mat[,!is_melanoma], path="../results/timer_input_ovarian.tsv")

res_timer_melanoma = immunedeconv::import_from_timer("../data/timer/timer_result_melanoma.csv")
res_timer_ovarian = immunedeconv::import_from_timer("../data/timer/timer_result_ovarian.csv")
res_timer = inner_join(res_timer_melanoma, res_timer_ovarian, by="cell_type") 
```

```{r}
abs_methods = c("cibersort_abs", "epic", "quantiseq", "xcell")
show_cell_types = c("B cell", "Dendritic cell", "Macrophage/Monocyte", "NK cell", "T cell CD4+", "T cell CD4+ (non-regulatory)", "T cell regulatory (Tregs)", "T cell CD8+", "Cancer associated fibroblast", "Endothelial cell")
```


## Results

Here, we map the results back to the "gold standard". We aggregate the results of the different methods
into a single table and clean it up for further processing. 
```{r, cache=TRUE}
all_results2 = all_results %>% 
  c(list("timer"=res_timer))
  
all_results3 = lapply(names(all_results2), function(method) {
  map_result_to_celltypes(all_results2[[method]], show_cell_types, method) %>%
    as_tibble(rownames="cell_type") %>%
    mutate(method=method)
}) 

all_results_tidy = all_results3 %>%
  bind_rows() %>%
  na.omit() %>% 
  gather(sample, estimate, -cell_type, -method) %>%
  arrange(method, cell_type, sample)

gold_standard = pData(bulk_eset) %>%
  t() %>%
  as_tibble(rownames="cell_type") %>% 
  map_result_to_celltypes(show_cell_types, "schelker_single_cell") %>% 
  rownames_to_column("cell_type") %>% 
  gather(sample, true_fraction, -cell_type)
```

### Calculate "Other cells" for all absolute methods
```{r}
other_cells_estimates = all_results_tidy %>% 
  filter(method %in% abs_methods) %>%
  group_by(method, sample) %>% 
  summarise(cell_type="Other", estimate=max(0, 1-sum(estimate)))

other_cells_true_fractions = gold_standard %>%
  inner_join(all_results_tidy %>% select(method, sample) %>% distinct(), by=c("sample")) %>%
  anti_join(all_results_tidy, by=c("sample", "cell_type", "method")) %>% 
  group_by(method, sample) %>% 
  summarise(cell_type="Other", true_fraction=sum(true_fraction))
```


```{r}
all_results_tidy2 = bind_rows(all_results_tidy, other_cells_estimates)

# we need to add the methods (full join) to each cell type as 
# the "Other" fractions are method specific
# (all cell types that are not predicted by the method)
gold_standard2 = gold_standard %>%
  crossing(method=unique(all_results_tidy$method)) %>% 
  bind_rows(other_cells_true_fractions)

results_with_gold_standard = all_results_tidy2 %>%
  inner_join(gold_standard2, by=c("sample", "cell_type", "method"))

```

### Correlation plots
```{r, fig.width=14, fig.height=8}


results_with_gold_standard %>%
  ggplot(aes(x=true_fraction, y=estimate)) +
  facet_grid(method ~ cell_type, scales="free") +
  geom_point() +
  stat_smooth(aes(color=method), method="lm") + 
  scale_color_manual(values=color_scales$methods) + 
  scale_x_continuous(breaks=c(.2, .5)) + 
  stat_cor()
```


### Calculate correlations for each method and cell type
```{r, fig.width=6, fig.height=5}
make_cor = function(estimate, true_fraction) {
  test_res = cor.test(estimate, true_fraction, method="pearson")
  data.frame(
    pearson=test_res$estimate,
    conf_int_lower=test_res$conf.int[1],
    conf_int_upper=test_res$conf.int[2]
  )
}

correlations = results_with_gold_standard %>%
  group_by(cell_type, method) %>%
  do(make_cor(.$estimate, .$true_fraction))

correlations %>% ggplot(aes(x=method, y=pearson)) +
  geom_bar(aes(fill=method), stat="identity") +
  geom_errorbar(aes(ymin=conf_int_lower, ymax=conf_int_upper), width=.2) + 
  facet_wrap(~cell_type, nrow=2) + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.position="top") +
  scale_fill_manual(values=color_scales$methods)
```


### Absolute error for all qualifying methods
```{r, fig.width=10, fig.height=4}

results_with_gold_standard %>% 
  filter(method %in% abs_methods) %>% 
  mutate(error=abs(estimate-true_fraction)) %>%
  mutate(square_error=error^2) %>% 
  ggplot(aes(x=method, y=square_error)) + 
    facet_wrap(~cell_type, nrow=1) + 
    geom_boxplot(aes(fill=method), width=1, position="dodge") +
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values=color_scales$methods) 

```

