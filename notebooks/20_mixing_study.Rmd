---
title: "Mixing study"
output: html_notebook
---

# Mixing study

In this chapter, we will use single cell data from [@Schelker2017] to create simulated bulk RNAseq samples 
of which we know the true cell proportions. We futher use these samples to benchmark the performance of different recently published immune deconvolution tools. 

## Average fraction of tumour cells
To obtain representatitive simulated samples, we are interested in the average fraction of tumour cells vs immune cells in a mixture. 

```{r}
cell_type_table = pData(single_cell_schelker2) %>%
  filter(source %in% c("melanoma", "ascites")) %>%
  mutate(sample=paste(source, donor, sep="_")) %>% 
  group_by(source, sample, cell_type) %>% 
  summarise(n=n()) %>%
  mutate(freq=n/sum(n))

ggplot(cell_type_table, aes(x=sample, y=freq)) +
  geom_bar(aes(fill=cell_type), stat="identity") + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  scale_fill_manual(values=color_scales$cell_types)


cancer_cells = cell_type_table %>% 
  filter(cell_type %in% c("Melanoma cells", "Ovarian carcinoma cells")) 


cancer_cell_param = MASS::fitdistr(cancer_cells$freq, "normal")
```



## Create simulated bulk tissues
```{r}
devtools::load_all("/storage/home/sturm/projects/immune_deconvolution_methods")
```

The fractions of a sample are randomly assigned in the following procedure: 

1. Draw a random tumour cell content from the distribution fitted above
2. The first half of the samples will use melanoma cells, the second half ovarian cancer cells. 
3. Assign the remaining fraction (=not cancer cells)  randomly to the remaining cell types (`r available_cell_types`)

```{r}
set.seed(42)

cancer_cells = c("Melanoma cells", "Ovarian carcinoma cells")
immune_cells = available_cell_types[!(available_cell_types %in% cancer_cells)]
is_melanoma = c(rep(TRUE, 50), rep(FALSE, 50))

cell_fractions = lapply(is_melanoma, function(melanoma) {
  cancer_fraction = rnorm(1, mean=cancer_cell_param$estimate[1], sd=cancer_cell_param$estimate[2])
  cancer_fraction = ifelse(cancer_fraction < 0, 0, cancer_fraction)
  cancer_fraction = ifelse(cancer_fraction > 1, 1, cancer_fraction)
  
  # associate fraction randomly ot Melanoma or Ovarian
  if(melanoma) {
    cancer_fractions = list(cancer_fraction, 0)
  } else {
    cancer_fractions = list(0, cancer_fraction)
  }
  names(cancer_fractions) = cancer_cells
  
  # compute random fractions for other cells
  remaining_fraction = 1 - cancer_fraction
  rnd = sample(0:100, length(immune_cells), TRUE)
  tmp_fractions = (remaining_fraction * rnd) / sum(rnd)
  names(tmp_fractions) = immune_cells
  
  c(cancer_fractions, tmp_fractions)
}) %>% bind_rows()

testthat::test_that("all fractions sum up to 1", expect_equal(apply(cell_fractions, 1, sum), rep(1, 100)))
```


```{r, cache=TRUE}
set.seed(42)
bulk_eset = make_bulk_eset(eset=single_cell_schelker2, cell_fractions = cell_fractions, n_cells=500)
```


## Run the deconvolution
We first run all methods that are integrated in the `immune_deconvolution_methods` are package automatically in a loop. 
```{r, cache=TRUE}
all_results = lapply(immunedeconv::deconvolution_methods, function(method) {
  deconvolute(bulk_eset, method, column="gene_symbol") %>%
    mutate(method=method)
})
```

### run CIBERSORT
We could not include CIBERSORT [@CIBERSORT2016] into the package due to licensing restrictions. 
In the following, we run CIBERSORT both in "normal" and "absolute" mode. 

```{r, cache=TRUE}
eset_mat = eset_to_matrix(bulk_eset, "gene_symbol")
res_cibersort = immunedeconv::deconvolute_cibersort(eset_mat, 
                                                    "../lib/CIBERSORT/CIBERSORT.R",
                                                    "../lib/CIBERSORT/LM22.txt") 
res_cibersort %<>% mutate(method="cibersort")

res_cibersort_abs = immunedeconv::deconvolute_cibersort(eset_mat, 
                                                    "../lib/CIBERSORT/CIBERSORT.R",
                                                    "../lib/CIBERSORT/LM22.txt",
                                                    absolute = TRUE) 
res_cibersort_abs %<>% mutate(method="cibersort_abs")
```

### run TIMER
TIMER [@TIMER2016] is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. 

We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. 

```{r, cache=TRUE}
eset_mat = eset_to_matrix(bulk_eset, "gene_symbol")
immunedeconv::export_for_timer(eset_mat[,is_melanoma], path="../results/timer_input_melanoma.tsv")
immunedeconv::export_for_timer(eset_mat[,!is_melanoma], path="../results/timer_input_ovarian.tsv")

res_timer_melanoma = immunedeconv::import_from_timer("../data/timer/timer_result_melanoma.csv")
res_timer_ovarian = immunedeconv::import_from_timer("../data/timer/timer_result_ovarian.csv")
res_timer = inner_join(res_timer_melanoma, res_timer_ovarian, by="cell_type") %>%
  mutate(method="timer")
```

## Results

Here, we map the results back to the "gold standard". We aggregate the results of the different methods
into a single table and clean it up for further processing. 
```{r, cache=TRUE}
all_results2 = all_results %>% 
  c(list(res_cibersort)) %>%
  c(list(res_cibersort_abs)) %>% 
  c(list(res_timer))

# summarise cell_types from the method that only map to a single cell_type in the reference dataset (namely monocytes and macrophages)
all_results3 = lapply(all_results2, function(res) {
  res %>% 
    map_results_to_dataset("single_cell_schelker") %>% 
    group_by(method, single_cell_schelker) %>%   
    summarise_all(funs(sum)) 
})

all_results_tidy = all_results3 %>%
  bind_rows() %>%
  rename(cell_type = single_cell_schelker) %>%
  gather(sample, estimate, -cell_type, -method) %>%
  arrange(method, cell_type, sample)

gold_standard = pData(bulk_eset) %>%
  rownames_to_column("sample") %>%
  gather(cell_type, true_fraction, -sample)

results_with_gold_standard = all_results_tidy %>%
  inner_join(gold_standard, by=c("sample", "cell_type"))

```

### Correlation plots
```{r, fig.width=12, fig.height=8}
results_with_gold_standard %>%
  ggplot(aes(x=true_fraction, y=estimate)) +
  facet_grid(method ~ cell_type, scales="free_y") +
  geom_point() +
  stat_smooth(aes(color=method), method="lm") + 
  scale_color_manual(values=color_scales$methods)
```


### Calculate correlations for each method and cell type
```{r}
make_cor = function(estimate, true_fraction) {
  test_res = cor.test(estimate, true_fraction, method="pearson")
  data.frame(
    pearson=test_res$estimate,
    conf_int_lower=test_res$conf.int[1],
    conf_int_upper=test_res$conf.int[2]
  )
}

correlations = results_with_gold_standard %>%
  group_by(cell_type, method) %>%
  do(make_cor(.$estimate, .$true_fraction))

correlations %>% ggplot(aes(x=method, y=pearson)) +
  geom_bar(aes(fill=method), stat="identity") +
  geom_errorbar(aes(ymin=conf_int_lower, ymax=conf_int_upper), width=.2) + 
  facet_wrap(~cell_type) + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  scale_fill_manual(values=color_scales$methods)
```


### Absolute error for all qualifying methods
```{r, fig.width=10, fig.height=4}
abs_methods = c("cibersort_abs", "epic", "quantiseq", "xcell")

results_with_gold_standard %>% 
  filter(method %in% abs_methods) %>% 
  mutate(error=abs(estimate-true_fraction)) %>%
  ggplot(aes(x=method, y=error)) + 
    facet_wrap(~cell_type, nrow=1) + 
    geom_boxplot(aes(fill=method), width=1, position="dodge") +
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values=color_scales$methods) 

```

