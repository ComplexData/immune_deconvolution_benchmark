# Detection limit and false positive predictions
```{r, include=FALSE}
res_sensitivity = new.env()
```

How many cells of a certain type do we need for a method to detect immune cell infiltration (=Detection limit)?
How many cells of a certain type are detected, although we know they are not there (=false positives)?

We again use the single cell dataset to simulate samples that consist of background cells
(i.e. non-immune cells: fibroblasts, endothelial cells cancer cells) and add an increasing amount
of immune cells of a certain type.

We define the detection limit as the minimal fraction at which the method the abundance of the cell type to
be significantly different from zero. We define false positives as the predicted fraction of a certain cell type
at zero inflitration level.

For each amount of immune cells, we generate 5 random samples to compute a confidence interval.

We use the following cell types:
```{r}
show_cell_types = c("B cell", "Dendritic cell", "Macrophage/Monocyte",
                    "NK cell", "T cell CD4+", "T cell CD8+")
```

```{r, echo=FALSE}
n_immune_cells = rep(c(seq(0, 50, 5)
                     , seq(60, 100, 10)
                     , seq(150, 500, 50)
                     , seq(600, 1000, 100)
                     ), 5)
```


```{r sens_generate_data, cache=FALSE, echo=FALSE}
sensitivity_analysis_file = "../results/cache/sensitivity_analysis_dataset.rda"
if(!file.exists(sensitivity_analysis_file)) {
  set.seed(42)
  res = foreach(input_cell_type = show_cell_types,
                .final = function(x) setNames(x, show_cell_types)) %dopar% {

                    expr_mat = lapply(n_immune_cells, function(k) {
                      cell_n = make_cell_fraction_vector(input_cell_type, k)
                      cell_frac = cell_n/sum(cell_n)
                      make_random_bulk(eset=single_cell_schelker$eset, cell_fractions = cell_frac, n_cells = sum(cell_n))
                    }) %>% bind_cols() %>% as.matrix()

                    rownames(expr_mat) = rownames(single_cell_schelker$eset %>% exprs())
                    expr_mat
    }

  sensitivity_analysis_dataset = res
  save(sensitivity_analysis_dataset, file=sensitivity_analysis_file)
} else {
  load(sensitivity_analysis_file)
}
```

```{r sens_deconvolute, fig.height=18, fig.width=25, cache=TRUE, echo=FALSE}
res = foreach(input_cell_type = show_cell_types,
              .final = function(x) setNames(x, show_cell_types)) %:%
  foreach(method = config$deconvolution_methods,
          .final = function(x) setNames(x, config$deconvolution_methods)) %dopar% {
    expr_mat = sensitivity_analysis_dataset[[input_cell_type]]
    # use SKCM, although samples will also contain ovarian cancer acsites cells.
    timer_indications = rep("SKCM", ncol(expr_mat))
    deconvolute(expr_mat, method, indications=timer_indications)
  }

sensitivity_analysis_res = res
```

```{r sens_process_data, cache=TRUE, echo=FALSE, message=FALSE}
# post process the deconvolution results
all_results = foreach(input_cell_type = show_cell_types,
        .combine=bind_rows) %:%
  foreach(method = config$deconvolution_methods,
          .combine=bind_rows) %do% {
    tmp_res = sensitivity_analysis_res[[input_cell_type]][[method]] %>%
                map_result_to_celltypes(show_cell_types, method) %>%
                na.omit()

    n_cell_df = tibble(sample=colnames(tmp_res),
                       n_immune_cells = n_immune_cells,
                       n_background_cells = sum(cell_types$n_background_cells))


    tmp_res %>%
      as_tibble(rownames = "cell_type") %>%
      gather(sample, estimate, -cell_type) %>%
      mutate(method=method, input_cell_type=input_cell_type) %>%
      inner_join(n_cell_df, by="sample")
} %>%
  mutate(frac_immune_cells = as.factor(round(n_immune_cells/sum(cell_types$n_background_cells) * 100, 2)))

all_results2 = all_results %>%
  select(-sample) %>%
  group_by_at(vars(-estimate)) %>%
  summarise_all(funs(mean, sd, n=length)) %>%
  mutate(ci=qt(0.975,df=n-1)*sd/sqrt(n)) %>%
  ungroup()
```

## Predictions with increasing immune cell content
```{r, fig.height=18, fig.width=25, echo=FALSE, fig.cap="We add an increasing amount of each cell type independently to the 1,800 background cells. The figure shows the predictions for each cell type and method at increasing infiltration levels. "}
all_results2 %>%
  ggplot(aes(x=frac_immune_cells, y=mean, colour=cell_type)) +
  #   geom_line() +
    geom_errorbar(aes(ymin=mean-ci, ymax=mean+ci)) +
    theme_bw() +
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.position="top") +
    facet_grid(method~input_cell_type, scales = "free_y") +
    scale_color_manual(values = color_scales$immune_cells)
```

The following about false positives and the detection limit are directly
derived from the data shown in the plot above.

## Detection Limit

```{r, warning=FALSE, message=FALSE, cache=TRUE, echo=FALSE}
# add fallback values, if none of the fractions exceed the specified value
results_inf_fallback = all_results2 %>%
  select(cell_type, method, input_cell_type) %>%
  distinct() %>%
  mutate(mean = if_else(cell_type == input_cell_type, Inf, 0), ci=0, frac_immune_cells = as.factor(Inf))

# omit unnecessary columns and append fallback Inf valuees
all_results3 = all_results2 %>%
  select(cell_type, method, input_cell_type, mean, ci, frac_immune_cells) %>%
  bind_rows(results_inf_fallback)

# add the 'reference cell type', i.e. the celltype that *should* be there as an additional column
ref_cell_type = all_results3 %>%
  filter(cell_type == input_cell_type) %>%
  select(input_cell_type, method, frac_immune_cells, ref_mean=mean, ref_ci=ci)

all_combinations = crossing(method=config$deconvolution_methods, input_cell_type=show_cell_types)

# filter and summarise, s.t. we end up having the minimal fraction at which the celltype is distinguishable from the others
sensitivity_plot = all_results3 %>%
  filter(cell_type != input_cell_type) %>%
  select(cell_type, method, input_cell_type, mean, ci, frac_immune_cells) %>%
  inner_join(ref_cell_type) %>%
  # at least 0.001 predicted to avoid numerical problems with very small values (-> xCell).
  # mutate(significantly_enriched = ref_mean-ci > mean+ci & ref_mean > 1e-3) %>%
  mutate(significantly_enriched = ref_mean-ci > 0 & ref_mean > 1e-4) %>%
  filter(significantly_enriched) %>%
  group_by(method, input_cell_type, cell_type) %>%
  summarise(min_frac = min(as.numeric(as.character(frac_immune_cells)))) %>%
  group_by(method, input_cell_type) %>%
  # must exceed *all* other cell types
  summarise(min_frac = max(as.numeric(as.character(min_frac)))) %>%
  right_join(all_combinations)

res_sensitivity$all_results = all_results3
res_sensitivity$sensitivity = sensitivity_plot
```

```{r sens_table, echo=FALSE, message=FALSE, warning=FALSE}
sensitivity_plot %>%
  mutate(min_frac = ifelse(is.infinite(min_frac), 100, min_frac)) %>%
  mutate(min_frac = min_frac / 100) %>%
  spread(input_cell_type, min_frac) %>%
  write_tsv("../results/tables/detection_limit.tsv", na="")
```

```{r sens-plot, fig.width=4, fig.height=4, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="Detection limit of the methods per cell type. The values indicate the minimal percentage of infiltration at which the method first reliably detects the cell type."}
sensitivity_plot %>%
  mutate(min_frac = ifelse(min_frac >100, 100, min_frac)) %>%
  mutate(min_frac_text = round(min_frac/100, 2)) %>%
  filter(method != "mcp_counter") %>%
  ggplot(aes(x=input_cell_type, y=method)) +
    geom_tile(aes(fill=min_frac)) +
    geom_text(aes(label=min_frac_text), size=2.7) +
    scale_fill_distiller(type="div", palette = "RdYlGn", direction=-1, values=c(0, .02, .1, 1)) +
    scale_alpha_manual(values=c("yes"=.3, "no"=1.)) +
    theme_benchmark() +
    theme(axis.text.x.top=element_text(angle = 90, vjust = .5, hjust=0),
            legend.position="none",
            strip.text.x = element_text(size=11)) +
    scale_x_discrete(position = "top", drop=FALSE) +
    xlab(NULL) +
    ylab(NULL) +
    theme_title()  +
    ggtitle("Detection limit")

```


## False-positive predictions

Predicted amount of cells when there are none.
This analysis is based on all of the data above where only background cells are present, i.e. fraction of immune cells = 0.

```{r sens_spec_table, echo=FALSE, message=FALSE}
sens_spec_table = all_results %>%
  filter(frac_immune_cells == 0, cell_type == input_cell_type) %>%
  select(cell_type, method, estimate) %>%
  group_by(cell_type, method) %>%
  summarise(median_estimate=median(estimate)) %>%
  spread(cell_type, median_estimate)

sens_spec_table %>%
  write_tsv("../results/tables/false_positives.tsv", na="")
```

```{r sens_spec_data, fig.height=6, fig.width=6, echo=FALSE}
specificity_data = all_results %>%
  select(-sample) %>%
  filter(frac_immune_cells == 0) %>%
  filter(method != "mcp_counter")

res_sensitivity$specificity = specificity_data
```

```{r, sens-spec-plot, fig.height=3, fig.width=12, echo=FALSE, fig.cap="Predicted amount of a certain cell type while it is actually absent."}
specificity_data %>%
  ggplot(aes(x=cell_type, y=estimate)) +
    geom_boxplot(position="dodge") +
    facet_wrap(~method, nrow=1) +
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1),
          legend.position="top",
          strip.text.x = element_text(size=9)) +
    scale_color_manual(values=color_scales$methods, na.value="grey") +
    coord_flip()
```

