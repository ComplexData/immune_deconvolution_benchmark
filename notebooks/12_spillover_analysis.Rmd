---
title: "Spillover analysis"
output: html_notebook
---

# Spillover analysis

In this chapter, we will use single cell data from [@Schelker2017] to create simulated pure immune cell RNA samples (and pure RNA samples from other studies (tbd)). We will then evaluate, if predictions of a certain immune cell type correlate with another.


```{r}
set.seed(42)

cell_fractions = lapply(available_cell_types, function(cell_type) {
  vec = as.list(rep(0., length(available_cell_types)))
  vec[[which(available_cell_types == cell_type)]] = 1.
  names(vec) = available_cell_types
  vec
}) %>% bind_rows()

testthat::test_that("all fractions sum up to 1", expect_equal(apply(cell_fractions, 1, sum), rep(1, length(available_cell_types))))
```


```{r, cache=TRUE}
set.seed(42)
bulk_eset = make_bulk_eset(eset=single_cell_schelker2, cell_fractions = cell_fractions, n_cells=500)
```


## Run the deconvolution
We first run all methods that are integrated in the `immune_deconvolution_methods` are package automatically in a loop. 
```{r, cache=TRUE, message=FALSE, results='hide'}
all_results = lapply(immunedeconv::deconvolution_methods, function(method) {
  print(sprintf("Running %s...", method))
  deconvolute(bulk_eset, method, column="gene_symbol") %>%
    mutate(method=method)
})
```

### run CIBERSORT
We could not include CIBERSORT [@CIBERSORT2016] into the package due to licensing restrictions. 
In the following, we run CIBERSORT both in "normal" and "absolute" mode. 

```{r, cache=TRUE}
eset_mat = eset_to_matrix(bulk_eset, "gene_symbol")
res_cibersort = immunedeconv::deconvolute_cibersort(eset_mat, 
                                                    "../lib/CIBERSORT/CIBERSORT.R",
                                                    "../lib/CIBERSORT/LM22.txt") 
res_cibersort %<>% mutate(method="cibersort")

res_cibersort_abs = immunedeconv::deconvolute_cibersort(eset_mat, 
                                                    "../lib/CIBERSORT/CIBERSORT.R",
                                                    "../lib/CIBERSORT/LM22.txt",
                                                    absolute = TRUE) 
res_cibersort_abs %<>% mutate(method="cibersort_abs")
```

### run TIMER
TIMER [@TIMER2016] is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. 

We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. 

```{r, cache=TRUE, message=FALSE}
eset_mat = eset_to_matrix(bulk_eset, "gene_symbol")
immunedeconv::export_for_timer(eset_mat, "../results/timer_spillover.csv")

res_timer = immunedeconv::import_from_timer("../data/timer/timer_result_spillover.csv") %>%
  mutate(method="timer")
```

## Results

Here, we map the results back to the "gold standard". We aggregate the results of the different methods
into a single table and clean it up for further processing. 
```{r, cache=TRUE}
all_results2 = all_results %>% 
  c(list(res_cibersort)) %>%
  c(list(res_cibersort_abs)) %>% 
  c(list(res_timer))

gold_standard = tibble(sample=colnames(eset_mat), true_cell_type=available_cell_types) %>% 
  filter(!true_cell_type %in% cancer_cells)

# # summarise cell_types from the method that only map to a single cell_type in the reference dataset (namely monocytes and macrophages)
all_results3 = lapply(all_results2, function(res) {
  res %>%
    map_results_to_dataset("single_cell_schelker") %>%
    group_by(method, single_cell_schelker) %>%
    summarise_all(funs(sum))
})

all_results_tidy = all_results3 %>%
  bind_rows() %>%
  rename(cell_type = single_cell_schelker) %>%
  gather(sample, estimate, -cell_type, -method) %>%
  inner_join(gold_standard, by="sample") %>%
  group_by(method, sample) %>%
  mutate(estimate_scaled = (estimate - min(estimate)) / (max(estimate) - min(estimate)), # add scaled estimate
         estimate_fraction = estimate/sum(estimate)) %>%
  mutate(signal = ifelse(sum(cell_type==true_cell_type)==1,estimate_fraction[cell_type==true_cell_type],NA),            # add signal and noise
         noise = sum(estimate_fraction[cell_type!=true_cell_type]),
         abs_noise = sum(estimate[cell_type!=true_cell_type])) %>% 
  ungroup() %>% 
  arrange(method, cell_type, sample)
```


```{r, fig.width=10, fig.height=10}
all_results_tidy %>%
  ggplot(aes(x=cell_type, y=true_cell_type)) +
  geom_tile(aes(fill=estimate_fraction)) + 
  facet_wrap(~method) + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  ggtitle("Spillover by Method") + 
  theme(panel.background=element_rect(fill="lightgrey"))
```
```{r, fig.width=10, fig.height=10}
all_results_tidy %>%
  ggplot(aes(x=cell_type, y=method)) +
  geom_tile(aes(fill=estimate_fraction)) + 
  facet_wrap(~true_cell_type) + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  ggtitle("Spillover by cell type") + 
  theme(panel.background=element_rect(fill="lightgrey"))
```

### Calculate signal to noise ratio for each cell type
```{r}
all_results_tidy %>%
  select(method, true_cell_type, signal, noise) %>%
  distinct() %>% 
  mutate(signal_to_noise = signal/(signal+noise)) %>% 
  ggplot(aes(x=method, y=signal_to_noise)) + 
    geom_bar(aes(fill=method), stat='identity') + 
    facet_wrap(~true_cell_type) + 
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values=color_scales$methods)

```

```{r}
all_results_tidy %>%
  select(method, true_cell_type, abs_noise) %>%
  distinct() %>% 
  filter(method %in% c("xcell", "quantiseq", "epic", "cibersort")) %>% 
  ggplot(aes(x=method, y=abs_noise)) + 
    geom_bar(aes(fill=method), stat='identity') + 
    facet_wrap(~true_cell_type) + 
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values=color_scales$methods)

```