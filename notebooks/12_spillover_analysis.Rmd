---
title: "Spillover analysis"
output: html_notebook
---

# Spillover analysis

In this chapter, we will use single cell data from [@Schelker2017] to create simulated pure immune cell RNA samples (and pure RNA samples from other studies (tbd)). We will then evaluate, if predictions of a certain immune cell type correlate with another.


```{r, cache=TRUE, message=FALSE}
immune_cell_samples = read_tsv("../data/immune_cell_reference_profiles/immune_cell_reference_tidy.tsv")

sample_description = immune_cell_samples %>% select(sample, CellType, Study) %>% distinct()

expr = immune_cell_samples %>%
  select(sample, hgnc_id, TPM) %>%
  group_by(sample, hgnc_id) %>%
  summarise(TPM = sum(TPM)) %>%
  spread(sample, TPM)

expr_mat = expr %>%
  as.data.frame() %>%
  column_to_rownames("hgnc_id") %>% 
  as.matrix() %>% 
  .[, sample_description$sample]

```

## Run the deconvolution
We first run all methods that are integrated in the `immune_deconvolution_methods` are package automatically in a loop. 
```{r, cache=TRUE, message=FALSE, results='hide'}
all_results = lapply(immunedeconv::deconvolution_methods, function(method) {
  print(sprintf("Running %s...", method))
  deconvolute(expr_mat, method) %>%
    mutate(method=method)
})
```

### run TIMER
TIMER [@TIMER2016] is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. 

We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. 

```{r, cache=TRUE, message=FALSE}
immunedeconv::export_for_timer(expr_mat, "../results/timer_input_spillover.tsv")

res_timer = immunedeconv::import_from_timer("../data/timer/timer_result_spillover.csv") %>%
  mutate(method="timer")
```

## Results

Here, we map the results back to the "gold standard". We aggregate the results of the different methods
into a single table and clean it up for further processing. 
```{r, cache=TRUE}
gold_standard = sample_description %>% select(sample, true_cell_type=CellType)

all_results2 = all_results %>% 
  c(list(res_timer))

# # summarise cell_types from the method that only map to a single cell_type in the reference dataset (namely monocytes and macrophages)
all_results3 = lapply(all_results2, function(res) {
  res %>%
    map_results_to_dataset("quantiseq_reference") %>%
    group_by(method, quantiseq_reference) %>%
    summarise_all(funs(sum))
})

all_results_tidy = all_results3 %>%
  bind_rows() %>%
  rename(cell_type = quantiseq_reference) %>%
  gather(sample, estimate, -cell_type, -method) %>%
  inner_join(gold_standard, by="sample") %>%
  group_by(method, sample) %>%
  mutate(estimate_scaled = (estimate - min(estimate)) / (max(estimate) - min(estimate)), # add scaled estimate
         estimate_fraction = estimate/sum(estimate)) %>%
  mutate(signal = ifelse(sum(cell_type==true_cell_type)==1,estimate_fraction[cell_type==true_cell_type],NA),            # add signal and noise
         noise = sum(estimate_fraction[cell_type!=true_cell_type]),
         abs_noise = sum(estimate[cell_type!=true_cell_type])) %>% 
  ungroup() %>% 
  arrange(method, cell_type, sample)
```


```{r, fig.width=10, fig.height=10}
all_results_tidy %>%
  ggplot(aes(x=cell_type, y=true_cell_type)) +
  geom_tile(aes(fill=estimate_fraction)) + 
  facet_wrap(~method) + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  ggtitle("Spillover by Method") + 
  theme(panel.background=element_rect(fill="lightgrey"))
```
```{r, fig.width=10, fig.height=10}
all_results_tidy %>%
  ggplot(aes(x=cell_type, y=method)) +
  geom_tile(aes(fill=estimate_fraction)) + 
  facet_wrap(~true_cell_type) + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  ggtitle("Spillover by cell type") + 
  theme(panel.background=element_rect(fill="lightgrey"))
```

### Calculate signal to noise ratio for each cell type
```{r}
all_results_tidy %>%
  select(method, true_cell_type, signal, noise) %>%
  distinct() %>% 
  mutate(signal_to_noise = signal/(signal+noise)) %>% 
  ggplot(aes(x=method, y=signal_to_noise)) + 
    geom_boxplot(aes(fill=method), position = "dodge") + 
    facet_wrap(~true_cell_type) + 
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values=color_scales$methods)

```

```{r}
all_results_tidy %>%
  select(method, true_cell_type, abs_noise) %>%
  distinct() %>% 
  filter(method %in% c("xcell", "quantiseq", "epic", "cibersort")) %>% 
  ggplot(aes(x=method, y=abs_noise)) + 
    geom_boxplot(aes(fill=method), position="dodge") + 
    facet_wrap(~true_cell_type) + 
    theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
    scale_fill_manual(values=color_scales$methods)

```