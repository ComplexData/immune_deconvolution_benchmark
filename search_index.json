[
["index.html", "Immune Deconvolution Benchmark 1 Introduction 1.1 Conceptual differences between methods", " Immune Deconvolution Benchmark Gregor Sturm 2018-06-04 1 Introduction There is urgent need for an unbiased comparison of existing immune deconvolution methods. We focus on RNA-seq only in this review, as current data, including large public efforts like TCGA, are likely generated using this technology. To our best knowlege, no such benchmark study has been performed yet, maybe due to the lack of an appropriate gold standard. Now, with the advent of large, publicly availble single-cell datasets this such a comparison becomes feasible. Systematic, methodological comparisons of such methods are available (Newman and Alizadeh 2016; Finotello and Trajanoski 2018; Avila Cobos et al. 2018). Here, we focus on algorithms, specifically developed for tumour immune cell deconvolution shipping with the appropriate signature matrix. While other, generic deconvolution altorithms are available (also reviewd in Finotello and Trajanoski (2018)), we do not take them into account here, as the resulting performance depends at least as much on the signature as on the method. The methods: MCPCounter (Becht et al. 2016) xCell (Aran, Hu, and Butte 2017) CIBERSORT (Aaron M. Newman, Chih Long Liu, Michael R. Green, Andrew J. Gentles, Weiguo Feng, Yue Xu, Chuong D. Hoang, Maximilian Diehn, A., and Alizadeh 2016) TIMER (B. Li et al. 2016) EPIC (Racle et al. 2017) quanTIseq (Finotello et al. 2017) TODO refer schelker paper 1.1 Conceptual differences between methods There are three conceptually different approaches to deconvolution. First, one can try to achieve scores suitable for inter-sample comparison. In that case, one can ask “Do I have more T cells in sample A than in sample B”, but one cannot ask “Do I have more B cells than T cells in sample A.”. This approach is used by GSEA-based methods like MCP counter. Second, one can try to build scores suitable for intra-sample comparison. In that case, one can ask “Do I have more B cells than T cells in sample A”, however one cannot draw conclusions about the abundance of T cells in sample A versus B, given there could also be other, unknown cell types in the sample (e.g. cancer cells). This approach is used by the default version of CIBERSORT) Last, ideally, one can build a score, that reflects the absolute quantity of a certain cell type in the sample. This approach allows both intra- and inter-sample comparisons. 1.1.1 Gene-set based methods (allow comparison between samples, but not between cell types) xCell (the authors apply some sort of normalization that makes xCell scores resemble percentages, although they advise doing this analysis with caution (ref). In this Benchmark, we will nonetheless try xCell both as “relative” and “absolute” method. MCPCounter (purely gene-expression based -&gt; between cell type comparison is simply wrong) TIMER (“not comparable between cancer types or different immune cells”) 1.1.2 Deconvolution-based methods (relative fractions, allow comparisons between cell types, but not samples) “relative to the total immune content” CIBERSORT (default mode) 1.1.3 Deconvolution-based methods (absolute fractions, allow comparisons between cell types and samples) CIBERSORT absolute mode (“Absolute mode scales relative cellular fractions into a score of arbitrary units that reflects the absolute proportion of each cell type in a mixture. Although not currently expressed as a fraction, the absolute score can be directly compared across cell types (i.e., relative differences between cell types are maintained)” [cibersort FAQ]) quanTIseq (uses cell fractions) EPIC (uses cell fractions) As CIBERSORT absolute scores are expressed in arbitrary units and not fractions, estimating the abundance of “Other cells” can be misleading. We will still try… References "],
["input-data.html", "2 Input data 2.1 cell type hierarchy 2.2 Single cell data for simulated mixtures 2.3 Immune cell bulk reference samples (quanTIseq training data) 2.4 Validation data (RNAseq + matched gold standard)", " 2 Input data In this chapter, we load and preprocess the different input datasets. We use a dedicated environment for each dataset in order not to trash the global namespace. 2.1 cell type hierarchy We use a hierachy of immune cell types to map the cell types between different datasets. Here is the hierachy visualized: cell_type_hierarchy = new.env() with(cell_type_hierarchy, { adj_list = read_excel(&quot;../tables/cell_type_mapping2.xlsx&quot;, sheet = &quot;controlled_vocabulary&quot;) %&gt;% select(parent, cell_type) tree = FromDataFrameNetwork(adj_list %&gt;% as.data.frame()) SetGraphStyle(tree, rankdir = &quot;LR&quot;) SetEdgeStyle(tree, arrowhead = &quot;vee&quot;, color = &quot;grey35&quot;, penwidth = 2) SetNodeStyle(tree, style = &quot;filled,rounded&quot;, shape = &quot;box&quot;, fillcolor = &quot;GreenYellow&quot;, fontname = &quot;helvetica&quot;, tooltip = GetDefaultTooltip, fontcolor=&quot;black&quot;) plot(tree) }) 2.2 Single cell data for simulated mixtures tmp_env = new.env() with(tmp_env, { load(&quot;../data/single_cell_schelker/single_cell_schelker.rda&quot;) # symbol_remap = read_tsv(&quot;../data/single_cell_schelker/symbol_checker.tsv&quot;) %&gt;% # as.data.frame() %&gt;% # column_to_rownames(&quot;Input&quot;) valid_cells = which(pData(single_cell_schelker)$cell_type!=&quot;Unknown&quot;) eset = single_cell_schelker[,valid_cells] # rownames(eset) = symbol_remap[,rownames(eset)]$`Approved symbol` assert_that(!any(pData(eset)$cell_type == &quot;Unknown&quot;)) }) ## [1] TRUE single_cell_schelker = new.env() single_cell_schelker$eset = tmp_env$eset cell_types = as.environment(list( available=pData(single_cell_schelker$eset) %&gt;% select(cell_type) %&gt;% distinct() %&gt;% pull(cell_type), cancer=c(&quot;Melanoma cells&quot;, &quot;Ovarian carcinoma cells&quot;), other=c(&quot;Cancer associated fibroblasts&quot;, &quot;Endothelial cells&quot;) )) cell_types$immune_cells = cell_types$available[!cell_types$available %in% c(cell_types$cancer, cell_types$other)] In this study, we make use of the single cell dataset curated by (Schelker et al. 2017). They aggregated single cell sequencing data from different sources resulting in a set of ~12,000 single cells. They classified the cells using at set of 45 marker genes into 11 categories: 2 cancer types (Melanoma cells, Ovarian carcinoma cells), 0 immune cells (), 2 other cells (Cancer associated fibroblasts, Endothelial cells) and Unknown cells which could not have been classified unambiguously. Unknown cells are excluded from the downstream analysis. the ~12,000 samples by cell type cell_type n B cells 1044 Cancer associated fibroblasts 132 CD4+ T cells 3023 CD8+ T cells 1884 Dendritic cells 166 Endothelial cells 71 Macrophages/Monocytes 2934 Melanoma cells 1310 Natural killer cells 425 Ovarian carcinoma cells 300 regulatory T cells 145 Figure 2.1: tSNE-clustering of the ~12000 single cells from (Schelker et al. 2017). 2.3 Immune cell bulk reference samples (quanTIseq training data) immune_cell_reference = new.env() with(immune_cell_reference, { tidy = read_tsv(&quot;../data/immune_cell_reference_profiles/immune_cell_reference_tidy.tsv&quot;) sample_description = tidy %&gt;% select(sample, CellType, Study) %&gt;% distinct() expr = tidy %&gt;% select(sample, hgnc_id, TPM) %&gt;% group_by(sample, hgnc_id) %&gt;% summarise(TPM = sum(TPM)) %&gt;% spread(sample, TPM) expr_mat = expr %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;hgnc_id&quot;) %&gt;% as.matrix() %&gt;% .[, sample_description$sample] }) 2.4 Validation data (RNAseq + matched gold standard) e.g. IHC, Flow cytometry, single cell validation_datasets = read_excel(&quot;../tables/validation-datasets.xlsx&quot;) kable(validation_datasets) Study # Samples Sample Type Gene Expression by Validation by Cell types Cited by Comments Got TPM Got Validation Finotello 2017 9 CRC RNAseq IHC CD3, CD8, CD45RO, FOXP3, PD1 NA Available upon publication NA NA Finotello 2017 9 PBMC/PMN RNAseq FlowCytometry B, Mono, Neu, NK, CD4, CD8, Treg, DC NA Available upon publication NA NA Hoeck 2015 8 PBMC/PMN RNAseq FlowCytometry T, B, NK, MDC, Mono, Neu Finotello 2017 Available through personal communicaion x x Johnson 2015 31 metastatic melanoma RNAseq IHC CD8, CD4, FOXP3+ Finotello 2017 How to get? NA NA Racle 2017 4 metastatic melanoma RNAseq FlowCytometry B, CD4, CD8, NK, Melanoma/other NA NA x x Zimmermann 2016 12 PBMC before influenza vacc RNAseq FlowCytometry B, CD4, CD8, NK, Mono, Other Racle 2017 obtained through Racle 2017 NA x Schelker 2017 3 ovarian cancer ascites RNAseq FlowCytometry + Single Cell RNAseq CD8, CD4, B, NK, DC, Mono, … NA NA x x Chung 2017 11 BRCA RNAseq Single Cell RNAseq + IHC for B and T NA NA NA NA NA 2.4.1 Hoeck data 8 PBMC, RNAseq+flow cytometry tmp_env = new.env() with(tmp_env, { load(&quot;../data/hoeck/HoekPBMC_mixture.RData&quot;) load(&quot;../data/hoeck/HoekPBMC_gtruth.RData&quot;) }) hoeck = new.env() hoeck$expr_mat = tmp_env$mix.mat hoeck$ref = tmp_env$RefData 2.4.2 Schelker data Load the data and merge replicates. 3 ovarian cancer ascites samplese which have matched flow cytometry/single cell/bulk data. schelker_ovarian = new.env() with(schelker_ovarian, { bulk_replicates = read_xls(&quot;../data/single_cell_schelker/ascites_bulk_samples.xls&quot;) samples = list(&quot;7873M&quot;=c(&quot;ascites_7873_1&quot;, &quot;ascites_7873_2&quot;), &quot;7882M&quot;=c(&quot;ascites_7882_1&quot;, &quot;ascites_7882_2&quot;), &quot;7892M&quot;=c(&quot;ascites_7892_1&quot;, &quot;ascites_7892_2&quot;)) bulk = lapply(samples, function(cols) { apply(bulk_replicates[,cols], 1, mean) }) %&gt;% bind_cols() bulk %&lt;&gt;% mutate(gene_symbol = bulk_replicates$Row) bulk_mat = bulk %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;gene_symbol&quot;) %&gt;% as.matrix() # Load the ground truth true_cell_count = pData(single_cell_schelker$eset) %&gt;% filter(source == &quot;ascites&quot;, donor %in% colnames(bulk)) %&gt;% group_by(donor, cell_type) %&gt;% count() %&gt;% rename(cell_count=n) %&gt;% group_by(donor) %&gt;% mutate(true_fraction=cell_count/sum(cell_count)) %&gt;% arrange(cell_type, donor) ref = true_cell_count %&gt;% select(sample=donor, cell_type, true_fraction) }) Single cell count for the 3 samples schelker_ovarian$true_cell_count %&gt;% group_by(donor) %&gt;% summarise(sum(cell_count)) %&gt;% kable() donor sum(cell_count) 7873M 864 7882M 902 7892M 773 schelker_ovarian$true_cell_count %&gt;% kable() donor cell_type cell_count true_fraction 7873M B cells 5 0.0057870 7882M B cells 4 0.0044346 7892M B cells 5 0.0064683 7873M Cancer associated fibroblasts 9 0.0104167 7882M Cancer associated fibroblasts 11 0.0121951 7892M Cancer associated fibroblasts 16 0.0206986 7873M CD4+ T cells 29 0.0335648 7882M CD4+ T cells 137 0.1518847 7892M CD4+ T cells 100 0.1293661 7873M CD8+ T cells 4 0.0046296 7882M CD8+ T cells 19 0.0210643 7892M CD8+ T cells 5 0.0064683 7873M Dendritic cells 27 0.0312500 7882M Dendritic cells 46 0.0509978 7892M Dendritic cells 39 0.0504528 7873M Macrophages/Monocytes 761 0.8807870 7882M Macrophages/Monocytes 599 0.6640798 7892M Macrophages/Monocytes 520 0.6727038 7873M Natural killer cells 10 0.0115741 7882M Natural killer cells 51 0.0565410 7892M Natural killer cells 42 0.0543338 7873M Ovarian carcinoma cells 19 0.0219907 7882M Ovarian carcinoma cells 34 0.0376940 7892M Ovarian carcinoma cells 46 0.0595084 7882M regulatory T cells 1 0.0011086 2.4.3 Racle data 4 metastatic melanoma, matched bulkRNAseq with FlowCytometry. tmp_env = new.env() with(tmp_env, { ensg_hgnc = read_tsv(&quot;../data/ensemble_hgnc.txt&quot;) %&gt;% rename(gene_id = `Gene stable ID`, hgnc_symbol=`HGNC symbol`) racle_cyto = read_excel(&quot;../data/racle/racle2017_flow_cytometry.xlsx&quot;) racle_files = list.files(&quot;../data/racle/GSE93722_RAW/&quot;, full.names = TRUE) racle_identifiers = str_extract(racle_files, &quot;LAU\\\\d+&quot;) racle_expression_raw = lapply(list.files(&quot;../data/racle/GSE93722_RAW/&quot;, full.names = TRUE), read_tsv) gene_ids = racle_expression_raw[[1]]$gene_id racle_tpm = sapply(racle_expression_raw, function(df) {pull(df, &quot;TPM&quot;)}) %&gt;% as.tibble() colnames(racle_tpm) = racle_identifiers racle_tpm$gene_id = gene_ids racle_expression = racle_tpm %&gt;% inner_join(ensg_hgnc) %&gt;% filter(!is.na(hgnc_symbol)) %&gt;% select(-gene_id) %&gt;% group_by(hgnc_symbol) %&gt;% summarise_all(sum) }) racle = new.env() racle$expr = tmp_env$racle_expression racle$expr_mat = racle$expr %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;hgnc_symbol&quot;) %&gt;% as.matrix() racle$ref = tmp_env$racle_cyto References "],
["validitiy-of-single-cell-rna-seq-as-reference.html", "3 Validitiy of single cell RNA-seq as reference 3.1 Validity of single cell sequencing for counting immune cells 3.2 Validity of simulated bulk tissues from single cell sequencing data 3.3 Correlated simulated samples with bulk of the same tissue.", " 3 Validitiy of single cell RNA-seq as reference 3.1 Validity of single cell sequencing for counting immune cells Schelker et al. (2017) have shown that measurements from single cell sequencing are highly consistent with flow cytometry. 3.2 Validity of simulated bulk tissues from single cell sequencing data We use simulated samples from single cell gene expression data. Does this approach make sense after all? We have 3 samples of single cell samples matched to bulk RNA sequencing. To test, we try: correlation of the simulated gene expression with the measured bulk gene expression. correlation of the predicted fractions with all methods on bulk vs. simulated tissue. correlation of the simulated gene expression with bulk gene expression from the same tissue. 3.2.1 Compare simululated samples to bulk samples Simulate bulk samples by summing up the expression values of all cells. bulk_sum = sapply(colnames(schelker_ovarian$bulk_mat), function(donor) { ind = pData(single_cell_schelker$eset)$donor == donor apply(exprs(single_cell_schelker$eset)[,ind], 1, sum) }) genes = intersect(rownames(bulk_sum), schelker_ovarian$bulk$gene_symbol) expr_all = bind_rows( schelker_ovarian$bulk %&gt;% mutate(source=&quot;bulk&quot;), bulk_sum %&gt;% as_tibble(rownames=&quot;gene_symbol&quot;) %&gt;% mutate(source=&quot;single_cell_aggregate&quot;) ) %&gt;% filter(gene_symbol %in% genes) %&gt;% gather(sample, tpm, -gene_symbol, -source) %&gt;% spread(source, tpm) expr_all %&gt;% mutate(bulk=log2(bulk+1), single_cell_aggregate=log2(single_cell_aggregate+1)) %&gt;% ggplot(aes(x=bulk, y=single_cell_aggregate)) + geom_point() + stat_cor() + facet_wrap(~sample) + geom_smooth(method = lm) 3.2.2 Compare the predicted fractions all_results_bulk = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(schelker_ovarian$bulk_mat, method) %&gt;% mutate(method=method) %&gt;% mutate(source=&quot;bulk&quot;) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 152/153 (99.35%) ## Mixture deconvolution (method: lsei) ## ## Attaching package: &#39;limSolve&#39; ## The following object is masked from &#39;package:ggplot2&#39;: ## ## resolution ## Deconvolution sucessful! all_results_simulated = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(bulk_sum, method) %&gt;% mutate(method=method) %&gt;% mutate(source=&quot;sum&quot;) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 140/153 (91.5%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## Warning in .local(expr, gset.idx.list, ...): 1genes with constant ## expression values throuhgout the samples. all_results = bind_rows(all_results_bulk, all_results_simulated) %&gt;% gather(donor, fraction, -cell_type, -source, -method) %&gt;% spread(source, fraction) all_results %&gt;% ggplot(aes(x = bulk, y=sum)) + geom_point(aes(colour=cell_type)) + facet_wrap(~method, scales=&quot;free&quot;) + stat_cor() 3.3 Correlated simulated samples with bulk of the same tissue. # immune_cell_reference # immune_cell_expr_mat cell_fractions = diag(length(cell_types$immune_cells)) cell_fractions = rbind(cell_fractions, cell_fractions, cell_fractions) colnames(cell_fractions) = cell_types$immune_cells rownames(cell_fractions) = unlist(lapply(1:3, function(i) {paste0(cell_types$immune_cells, &quot;_&quot;, i)})) simulated_bulk = make_bulk_eset(eset=single_cell_schelker$eset, cell_fractions = cell_fractions, n_cells=500, combine=sum) %&gt;% exprs() simulated_bulk = log2(simulated_bulk+1) colnames(simulated_bulk) = rownames(cell_fractions) immune_bulk = log2(immune_cell_reference$expr_mat+1) colnames(immune_bulk) = paste(immune_cell_reference$sample_description$CellType, immune_cell_reference$sample_description$sample) common_symbols = intersect(rownames(simulated_bulk), rownames(immune_bulk)) # all_samples = cbind(simulated_bulk[common_symbols,], immune_bulk[common_symbols, ]) # pheatmap(all_samples, cluster_rows = FALSE, cluster_cols = TRUE, clustering_distance_cols=&quot;correlation&quot;) cor(simulated_bulk[common_symbols,], immune_bulk[common_symbols,]) %&gt;% pheatmap() References "],
["sensitivity-analysis.html", "4 Sensitivity analysis", " 4 Sensitivity analysis How many cells do we need for a method to detect immune cell infiltration? if(!file.exists(&quot;../results/sensitivity_analysis_res.rda&quot;)) { background_cells = c(cell_types$cancer, cell_types$other) n_background_cells = single_cell_schelker$eset %&gt;% pData() %&gt;% filter(cell_type %in% background_cells) %&gt;% group_by(cell_type) %&gt;% count() %&gt;% {&#39;names&lt;-&#39;(.$n, .$cell_type)} n_immune_cells = rep(c(0:10 , seq(15, 50, 5) , seq(60, 100, 10) , seq(200, 1000, 100) ), 5) registerDoMC(cores=16) res = foreach(input_cell_type = cell_types$immune_cells, .combine=bind_rows) %:% foreach(method = immunedeconv::deconvolution_methods, .combine=bind_rows) %dopar% { expr_mat = lapply(n_immune_cells, function(n) { cell_n = c(n_background_cells, n) names(cell_n) = c(names(n_background_cells), input_cell_type) cell_frac = cell_n/sum(cell_n) make_random_bulk(eset=single_cell_schelker$eset, cell_fractions = cell_frac, n_cells = sum(cell_n)) }) %&gt;% bind_cols() %&gt;% as.matrix() rownames(expr_mat) = rownames(single_cell_schelker$eset %&gt;% exprs()) deconv_res = deconvolute(expr_mat, method) deconv_res2 = deconv_res %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;cell_type&quot;) %&gt;% t() %&gt;% as.data.frame() deconv_res2$n_cells = as.factor(n_immune_cells) deconv_res2 %&lt;&gt;% gather(cell_type, estimate, -n_cells) %&gt;% mutate(method=method, input_cell_type=input_cell_type) } sensitivity_analysis_res = res save(sensitivity_analysis_res, file=&quot;../results/sensitivity_analysis_res.rda&quot;) } load(&quot;../results/sensitivity_analysis_res.rda&quot;) sensitivity_analysis_res %&gt;% # filter(cell_type %in% c(&quot;T CD8+ (CTL)&quot;, &quot;T CD4+ (naïve)&quot;)) %&gt;% group_by(method, input_cell_type, cell_type, n_cells) %&gt;% summarise_all(funs(mean, sd, n=length)) %&gt;% mutate(ci=qt(0.975,df=n-1)*sd/sqrt(n)) %&gt;% ggplot(aes(x=n_cells, y=mean, colour=cell_type)) + geom_line() + geom_errorbar(aes(ymin=mean-ci, ymax=mean+ci)) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1), legend.position=&quot;top&quot;) + facet_grid(method~input_cell_type, scales = &quot;free_y&quot;) "],
["specificity-analysis.html", "5 Specificity Analysis 5.1 Create datasets 5.2 Run the deconvolution 5.3 Results", " 5 Specificity Analysis 5.1 Create datasets immune reference: bulk RNA seq profiles from sorted immune cells (=quanTIseq training data) artificial bulk: simulated bulk RNA seq profiles from single cells (e.g. only T cells) artificial bulk with background: simulated bulk RNA seq profiles from single cells with ~80% other cells (cancer, fibroblasts, …) background_cells = c(cell_types$cancer, cell_types$other) n_background_cells = single_cell_schelker$eset %&gt;% pData() %&gt;% filter(cell_type %in% background_cells) %&gt;% group_by(cell_type) %&gt;% count() %&gt;% {&#39;names&lt;-&#39;(.$n, .$cell_type)} frac_background_cells = n_background_cells/sum(n_background_cells) sample_types = rep(cell_types$immune_cells, 5) ## make artificial bulk sample artificial_bulk = lapply(sample_types, function(cell_type) { cell_frac = c(1.) names(cell_frac) = cell_type make_random_bulk(single_cell_schelker$eset, cell_frac, n_cells=500) }) %&gt;% bind_cols() %&gt;% as.matrix() rownames(artificial_bulk) = rownames(single_cell_schelker$eset %&gt;% exprs()) ## make artificial bulk samples with background artificial_bulk_bg = lapply(sample_types, function(cell_type) { cell_frac = c(.3, .7*frac_background_cells) names(cell_frac) = c(cell_type, names(frac_background_cells)) make_random_bulk(single_cell_schelker$eset, cell_frac, n_cells=500) }) %&gt;% bind_cols() %&gt;% as.matrix() rownames(artificial_bulk_bg) = rownames(single_cell_schelker$eset %&gt;% exprs()) 5.2 Run the deconvolution We first run all methods that are integrated in the immune_deconvolution_methods are package automatically in a loop. datasets = list( immune_reference = immune_cell_reference$expr_mat, artificial_bulk = artificial_bulk, artificial_bulk_bg = artificial_bulk_bg ) dataset_gold_standard = list( immune_reference = immune_cell_reference$sample_description %&gt;% select(sample, true_cell_type=CellType), artificial_bulk = tibble(sample=colnames(artificial_bulk), true_cell_type=sample_types), artificial_bulk_bg = tibble(sample=colnames(artificial_bulk), true_cell_type=sample_types) ) all_results_file = &quot;../results/specificity_analysis_res.rda&quot; if(!file.exists(all_results_file)) { all_results = foreach(dataset = datasets, dataset_name = names(datasets), gold_standard = dataset_gold_standard, .combine=bind_rows) %:% foreach(method = immunedeconv::deconvolution_methods, .combine=bind_rows) %dopar% { print(sprintf(&quot;Running %s...&quot;, method)) deconvolute(dataset, method) %&gt;% mutate(method=method, dataset=dataset_name) %&gt;% gather(sample, estimate, -cell_type, -method, -dataset) %&gt;% inner_join(gold_standard) } save(all_results, file=all_results_file) } load(all_results_file) 5.3 Results all_results %&gt;% ggplot(aes(x=cell_type, y=estimate, fill=dataset)) + geom_boxplot(position = position_dodge2(preserve = &quot;total&quot;)) + facet_grid(method~true_cell_type, scales=&quot;free_y&quot;) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) "],
["correlation-of-methods-across-tcga-samples-.html", "6 Correlation of methods across TCGA samples.", " 6 Correlation of methods across TCGA samples. tcga_infiltration = tbl(tcga_db, &quot;infiltration&quot;) %&gt;% collect() %&gt;% mutate(method_cell_type = paste0(cell_type, &quot; [&quot;, method, &quot;]&quot;)) %&gt;% select(sample, method_cell_type, estimate) %&gt;% spread(method_cell_type, estimate) tcga_infil_mat = tcga_infiltration %&gt;% select(-sample) %&gt;% as.matrix() tcga_cor = cor(tcga_infil_mat) pheatmap(tcga_cor, clustering_distance_rows = &quot;correlation&quot;, clustering_distance_cols = &quot;correlation&quot;) "],
["mixing-study.html", "7 Mixing study 7.1 Average fraction of tumour cells 7.2 Create simulated bulk tissues 7.3 Run the deconvolution 7.4 Results", " 7 Mixing study In this chapter, we will use single cell data from (Schelker et al. 2017) to create simulated bulk RNAseq samples of which we know the true cell proportions. We futher use these samples to benchmark the performance of different recently published immune deconvolution tools. 7.1 Average fraction of tumour cells To obtain representatitive simulated samples, we are interested in the average fraction of tumour cells vs immune cells in a mixture. cell_type_table = pData(single_cell_schelker$eset) %&gt;% filter(source %in% c(&quot;melanoma&quot;, &quot;ascites&quot;)) %&gt;% mutate(sample=paste(source, donor, sep=&quot;_&quot;)) %&gt;% group_by(source, sample, cell_type) %&gt;% summarise(n=n()) %&gt;% mutate(freq=n/sum(n)) ggplot(cell_type_table, aes(x=sample, y=freq)) + geom_bar(aes(fill=cell_type), stat=&quot;identity&quot;) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_fill_manual(values=color_scales$cell_types) cancer_cells = cell_type_table %&gt;% filter(cell_type %in% c(&quot;Melanoma cells&quot;, &quot;Ovarian carcinoma cells&quot;)) cancer_cell_param = MASS::fitdistr(cancer_cells$freq, &quot;normal&quot;) 7.2 Create simulated bulk tissues The fractions of a sample are randomly assigned in the following procedure: Draw a random tumour cell content from the distribution fitted above The first half of the samples will use melanoma cells, the second half ovarian cancer cells. Assign the remaining fraction (=not cancer cells) randomly to the remaining cell types (B cells, CD8+ T cells, Melanoma cells, CD4+ T cells, Macrophages/Monocytes, regulatory T cells, Cancer associated fibroblasts, Dendritic cells, Endothelial cells, Natural killer cells, Ovarian carcinoma cells) set.seed(42) is_melanoma = c(rep(TRUE, 50), rep(FALSE, 50)) cell_fractions = lapply(is_melanoma, function(melanoma) { cancer_fraction = rnorm(1, mean=cancer_cell_param$estimate[1], sd=cancer_cell_param$estimate[2]) cancer_fraction = ifelse(cancer_fraction &lt; 0, 0, cancer_fraction) cancer_fraction = ifelse(cancer_fraction &gt; 1, 1, cancer_fraction) # associate fraction randomly ot Melanoma or Ovarian if(melanoma) { cancer_fractions = list(cancer_fraction, 0) } else { cancer_fractions = list(0, cancer_fraction) } names(cancer_fractions) = cell_types$cancer # compute random fractions for other cells remaining_fraction = 1 - cancer_fraction rnd = sample(0:100, length(cell_types$immune_cells), TRUE) tmp_fractions = (remaining_fraction * rnd) / sum(rnd) names(tmp_fractions) = cell_types$immune_cells c(cancer_fractions, tmp_fractions) }) %&gt;% bind_rows() testthat::test_that(&quot;all fractions sum up to 1&quot;, expect_equal(apply(cell_fractions, 1, sum), rep(1, 100))) set.seed(42) bulk_eset = make_bulk_eset(eset=single_cell_schelker$eset, cell_fractions = cell_fractions, n_cells=500) 7.3 Run the deconvolution We first run all methods that are integrated in the immune_deconvolution_methods are package automatically in a loop. all_results = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(bulk_eset, method, column=&quot;gene_symbol&quot;) %&gt;% mutate(method=method) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): The optimization didn&#39;t fully converge for some samples: ## value11; value14; value25; value26; value37; value38; value40; value51; value83; value93 ## - check fit.gof for the convergeCode and convergeMessage ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 140/153 (91.5%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! 7.3.1 run TIMER TIMER (B. Li et al. 2016) is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. eset_mat = eset_to_matrix(bulk_eset, &quot;gene_symbol&quot;) immunedeconv::export_for_timer(eset_mat[,is_melanoma], path=&quot;../results/timer_input_melanoma.tsv&quot;) immunedeconv::export_for_timer(eset_mat[,!is_melanoma], path=&quot;../results/timer_input_ovarian.tsv&quot;) res_timer_melanoma = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_melanoma.csv&quot;) ## Parsed with column specification: ## cols( ## sampleID = col_character(), ## B_cell = col_double(), ## T_cell.CD4 = col_double(), ## T_cell.CD8 = col_double(), ## Neutrophil = col_double(), ## Macrophage = col_double(), ## DC = col_double() ## ) res_timer_ovarian = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_ovarian.csv&quot;) ## Parsed with column specification: ## cols( ## sampleID = col_character(), ## B_cell = col_double(), ## T_cell.CD4 = col_double(), ## T_cell.CD8 = col_double(), ## Neutrophil = col_double(), ## Macrophage = col_double(), ## DC = col_double() ## ) res_timer = inner_join(res_timer_melanoma, res_timer_ovarian, by=&quot;cell_type&quot;) %&gt;% mutate(method=&quot;timer&quot;) abs_methods = c(&quot;cibersort_abs&quot;, &quot;epic&quot;, &quot;quantiseq&quot;, &quot;xcell&quot;) 7.4 Results Here, we map the results back to the “gold standard”. We aggregate the results of the different methods into a single table and clean it up for further processing. all_results2 = all_results %&gt;% c(list(res_timer)) # summarise cell_types from the method that only map to a single cell_type in the reference dataset (namely monocytes and macrophages) all_results3 = lapply(all_results2, function(res) { res %&gt;% map_results_to_dataset(&quot;single_cell_schelker&quot;) %&gt;% group_by(method, single_cell_schelker) %&gt;% summarise_all(funs(sum)) }) all_results_tidy = all_results3 %&gt;% bind_rows() %&gt;% rename(cell_type = single_cell_schelker) %&gt;% gather(sample, estimate, -cell_type, -method) %&gt;% arrange(method, cell_type, sample) gold_standard = pData(bulk_eset) %&gt;% rownames_to_column(&quot;sample&quot;) %&gt;% gather(cell_type, true_fraction, -sample) 7.4.1 Calculate “Other cells” for all absolute methods other_cells_estimates = all_results_tidy %&gt;% filter(method %in% abs_methods) %&gt;% group_by(method, sample) %&gt;% summarise(cell_type=&quot;Other&quot;, estimate=max(0, 1-sum(estimate))) other_cells_true_fractions = gold_standard %&gt;% inner_join(all_results_tidy %&gt;% select(method, sample) %&gt;% distinct(), by=c(&quot;sample&quot;)) %&gt;% anti_join(all_results_tidy, by=c(&quot;sample&quot;, &quot;cell_type&quot;, &quot;method&quot;)) %&gt;% group_by(method, sample) %&gt;% summarise(cell_type=&quot;Other&quot;, true_fraction=sum(true_fraction)) all_results_tidy2 = bind_rows(all_results_tidy, other_cells_estimates) # we need to add the methods (full join) to each cell type as # the &quot;Other&quot; fractions are method specific # (all cell types that are not predicted by the method) gold_standard2 = gold_standard %&gt;% crossing(method=unique(all_results_tidy$method)) %&gt;% bind_rows(other_cells_true_fractions) results_with_gold_standard = all_results_tidy2 %&gt;% inner_join(gold_standard2, by=c(&quot;sample&quot;, &quot;cell_type&quot;, &quot;method&quot;)) 7.4.2 Correlation plots results_with_gold_standard %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + facet_grid(method ~ cell_type, scales=&quot;free&quot;) + geom_point() + stat_smooth(aes(color=method), method=&quot;lm&quot;) + scale_color_manual(values=color_scales$methods) + scale_x_continuous(breaks=c(.2, .5)) 7.4.3 Calculate correlations for each method and cell type make_cor = function(estimate, true_fraction) { test_res = cor.test(estimate, true_fraction, method=&quot;pearson&quot;) data.frame( pearson=test_res$estimate, conf_int_lower=test_res$conf.int[1], conf_int_upper=test_res$conf.int[2] ) } correlations = results_with_gold_standard %&gt;% group_by(cell_type, method) %&gt;% do(make_cor(.$estimate, .$true_fraction)) correlations %&gt;% ggplot(aes(x=method, y=pearson)) + geom_bar(aes(fill=method), stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=conf_int_lower, ymax=conf_int_upper), width=.2) + facet_wrap(~cell_type, nrow=2) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1), legend.position=&quot;top&quot;) + scale_fill_manual(values=color_scales$methods) 7.4.4 Absolute error for all qualifying methods results_with_gold_standard %&gt;% filter(method %in% abs_methods) %&gt;% mutate(error=abs(estimate-true_fraction)) %&gt;% mutate(square_error=error^2) %&gt;% ggplot(aes(x=method, y=square_error)) + facet_wrap(~cell_type, nrow=1) + geom_boxplot(aes(fill=method), width=1, position=&quot;dodge&quot;) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_fill_manual(values=color_scales$methods) References "],
["validation-with-real-data.html", "8 Validation with real data 8.1 Run the deconvolution", " 8 Validation with real data We the curated datasets with gold standard as an additional validation on top of the mixing study. 8.1 Run the deconvolution We first run all methods that are integrated in the immune_deconvolution_methods are package automatically in a loop. all_results_racle = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(racle$expr_mat, method) %&gt;% mutate(method=method) %&gt;% map_results_to_dataset(&quot;racle&quot;) %&gt;% group_by(method, racle) %&gt;% summarise_all(funs(sum)) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 148/153 (96.73%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! all_results_hoeck = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(hoeck$expr_mat, method) %&gt;% mutate(method=method) %&gt;% map_results_to_dataset(&quot;hoeck&quot;) %&gt;% group_by(method, hoeck) %&gt;% summarise_all(funs(sum)) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 153/153 (100%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! all_results_schelker = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(schelker_ovarian$bulk_mat, method) %&gt;% mutate(method=method) %&gt;% map_results_to_dataset(&quot;single_cell_schelker&quot;) %&gt;% group_by(method, single_cell_schelker) %&gt;% summarise_all(funs(sum)) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 152/153 (99.35%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! # immunedeconv::export_for_timer(ovarian_bulk_mat, path=&quot;../results/timer_input_ovarian_bulk.tsv&quot;) # # res_timer = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_ovarian_bulk.csv&quot;) %&gt;% # mutate(method=&quot;timer&quot;) hoeck_ref2 = hoeck$ref %&gt;% as_tibble(rownames=&quot;sample&quot;) %&gt;% gather(cell_type, true_fraction, -sample) hoeck2 = bind_rows(all_results_hoeck) %&gt;% gather(sample, estimate, -method, -hoeck) %&gt;% mutate(dataset=&quot;hoeck&quot;) %&gt;% rename(cell_type=hoeck) %&gt;% inner_join(hoeck_ref2) ## Joining, by = c(&quot;cell_type&quot;, &quot;sample&quot;) racle_ref2 = racle$ref %&gt;% rename(sample=`donor ID`) %&gt;% gather(cell_type, true_fraction, -sample) %&gt;% mutate(true_fraction=true_fraction/100) racle2 = bind_rows(all_results_racle) %&gt;% gather(sample, estimate, -method, -racle) %&gt;% mutate(dataset=&quot;racle&quot;) %&gt;% rename(cell_type=racle) %&gt;% inner_join(racle_ref2) ## Joining, by = c(&quot;cell_type&quot;, &quot;sample&quot;) schelker_ref2 = schelker_ovarian$ref schelker2 = bind_rows(all_results_schelker) %&gt;% gather(sample, estimate, -method, -single_cell_schelker) %&gt;% mutate(dataset=&quot;single_cell_schelker&quot;) %&gt;% rename(cell_type=single_cell_schelker) %&gt;% inner_join(schelker_ref2) ## Joining, by = c(&quot;cell_type&quot;, &quot;sample&quot;) all_results_tidy_val = bind_rows(hoeck2, racle2, schelker2) %&gt;% ungroup() all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;B cells&quot;, &quot;Bcells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;B cells&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;Dendritic cells&quot;, &quot;DC&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;Dendritic cells&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;CD8+ T cells&quot;, &quot;CD8 T cells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;CD8 T&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;CD4+ T cells&quot;, &quot;CD4 T cells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;CD4 T&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;Natural killer cells&quot;, &quot;NK&quot;, &quot;NK cells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;NK&quot;) "],
["conclusions.html", "9 Conclusions", " 9 Conclusions Not sure if the methodology is valid after all? Anyway, conclusions: * Some cell types (CTL) are easier to detect that others (DC) * The deconvolution methodology is not the bottleneck, it’s the availability of reliable signatures precise definition can be controlversial (Jaitin 2014, Science, References 4-7) is based on inderect association of function with cell surface markers (5-8). "],
["materials-and-methods.html", "10 Materials and Methods 10.1 Data acquisition 10.2 Validation datasets (Flow cytometry, scRNAseq, Imageing + matched RNA seq)", " 10 Materials and Methods 10.1 Data acquisition For the single cell dataset by Schelker et al. (2017), we obtained the MATLAB source code deposited on figshare and used it to re-produced the dataset. The final dataset was exported to csv format in order to continue the main analysis in R. We obtained the 3 matched ovarian cancer bulk RNA samples from Schelker et al. (2017) (personal communication). 10.2 Validation datasets (Flow cytometry, scRNAseq, Imageing + matched RNA seq) Describe how the datasets were obtained References "],
["references.html", "11 References", " 11 References "]
]
