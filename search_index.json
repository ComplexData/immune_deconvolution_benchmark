[
["index.html", "Immune Deconvolution Benchmark 1 Introduction 1.1 Conceptual differences between methods", " Immune Deconvolution Benchmark Gregor Sturm 2018-05-08 1 Introduction There is urgent need for an unbiased comparison of existing immune deconvolution methods. We focus on RNA-seq only in this review, as current data, including large public efforts like TCGA, are likely generated using this technology. To our best knowlege, no such benchmark study has been performed yet, maybe due to the lack of an appropriate gold standard. Now, with the advent of large, publicly availble single-cell datasets this such a comparison becomes feasible. Systematic, methodological comparisons of such methods are available (Newman and Alizadeh 2016; Finotello and Trajanoski 2018; Avila Cobos et al. 2018). Here, we focus on algorithms, specifically developed for tumour immune cell deconvolution shipping with the appropriate signature matrix. While other, generic deconvolution altorithms are available (also reviewd in Finotello and Trajanoski (2018)), we do not take them into account here, as the resulting performance depends at least as much on the signature as on the method. The methods: MCPCounter (Becht et al. 2016) xCell (Aran, Hu, and Butte 2017) CIBERSORT (Aaron M. Newman, Chih Long Liu, Michael R. Green, Andrew J. Gentles, Weiguo Feng, Yue Xu, Chuong D. Hoang, Maximilian Diehn, A., and Alizadeh 2016) TIMER (B. Li et al. 2016) EPIC (Racle et al. 2017) quanTIseq (Finotello et al. 2017) TODO refer schelker paper 1.1 Conceptual differences between methods There are three conceptually different approaches to deconvolution. First, one can try to achieve scores suitable for inter-sample comparison. In that case, one can ask “Do I have more T cells in sample A than in sample B”, but one cannot ask “Do I have more B cells than T cells in sample A.”. This approach is used by GSEA-based methods like MCP counter. Second, one can try to build scores suitable for intra-sample comparison. In that case, one can ask “Do I have more B cells than T cells in sample A”, however one cannot draw conclusions about the abundance of T cells in sample A versus B, given there could also be other, unknown cell types in the sample (e.g. cancer cells). This approach is used by the default version of CIBERSORT) Last, ideally, one can build a score, that reflects the absolute quantity of a certain cell type in the sample. This approach allows both intra- and inter-sample comparisons. 1.1.1 Gene-set based methods (allow comparison between samples, but not between cell types) xCell (the authors apply some sort of normalization that makes xCell scores resemble percentages, although they advise doing this analysis with caution (ref). In this Benchmark, we will nonetheless try xCell both as “relative” and “absolute” method. MCPCounter (purely gene-expression based -&gt; between cell type comparison is simply wrong) TIMER (“not comparable between cancer types or different immune cells”) 1.1.2 Deconvolution-based methods (relative fractions, allow comparisons between cell types, but not samples) “relative to the total immune content” CIBERSORT (default mode) 1.1.3 Deconvolution-based methods (absolute fractions, allow comparisons between cell types and samples) CIBERSORT absolute mode (“Absolute mode scales relative cellular fractions into a score of arbitrary units that reflects the absolute proportion of each cell type in a mixture. Although not currently expressed as a fraction, the absolute score can be directly compared across cell types (i.e., relative differences between cell types are maintained)” [cibersort FAQ]) quanTIseq (uses cell fractions) EPIC (uses cell fractions) As CIBERSORT absolute scores are expressed in arbitrary units and not fractions, estimating the abundance of “Other cells” can be misleading. We will still try… References "],
["input-data.html", "2 Input data 2.1 Single cell data for simulated mixtures 2.2 Validation data (RNAseq + matched gold standard)", " 2 Input data 2.1 Single cell data for simulated mixtures load(&quot;../data/single_cell_schelker/single_cell_schelker.rda&quot;) In this study, we make use of the single cell dataset curated by (Schelker et al. 2017). They aggregated single cell sequencing data from different sources resulting in a set of ~12,000 single cells. They classified the cells using at set of 45 marker genes into 11 categories: 2 cancer types (Melanoma cells, Ovarian carcinoma cells), 7 immune cells (B cells, CD8+ T cells, CD4+ T cells, Macrophages/Monocytes, regulatory T cells, Dendritic cells, Natural killer cells), 2 other cells (Cancer associated fibroblasts, Endothelial cells) and Unknown cells which could not have been classified unambiguously. Unknown cells are excluded from the downstream analysis. the ~12,000 samples by cell type cell_type n B cells 1044 Cancer associated fibroblasts 132 CD4+ T cells 3023 CD8+ T cells 1884 Dendritic cells 166 Endothelial cells 71 Macrophages/Monocytes 2934 Melanoma cells 1310 Natural killer cells 425 Ovarian carcinoma cells 300 regulatory T cells 145 Unknown 325 Figure 2.1: tSNE-clustering of the ~12000 single cells from (Schelker et al. 2017). 2.2 Validation data (RNAseq + matched gold standard) e.g. IHC, Flow cytometry, single cell datasets = read_excel(&quot;../tables/validation-datasets.xlsx&quot;) kable(datasets) Study # Samples Sample Type Gene Expression by Validation by Cell types Cited by Comments Got TPM Got Validation Finotello 2017 9 CRC RNAseq IHC CD3, CD8, CD45RO, FOXP3, PD1 NA Available upon publication NA NA Finotello 2017 9 PBMC/PMN RNAseq FlowCytometry B, Mono, Neu, NK, CD4, CD8, Treg, DC NA Available upon publication NA NA Hoeck 2015 8 PBMC/PMN RNAseq FlowCytometry T, B, NK, MDC, Mono, Neu Finotello 2017 Available through personal communicaion x x Johnson 2015 31 metastatic melanoma RNAseq IHC CD8, CD4, FOXP3+ Finotello 2017 How to get? NA NA Racle 2017 4 metastatic melanoma RNAseq FlowCytometry B, CD4, CD8, NK, Melanoma/other NA NA x x Zimmermann 2016 12 PBMC before influenza vacc RNAseq FlowCytometry B, CD4, CD8, NK, Mono, Other Racle 2017 obtained through Racle 2017 NA x Schelker 2017 3 ovarian cancer ascites RNAseq FlowCytometry + Single Cell RNAseq CD8, CD4, B, NK, DC, Mono, … NA NA x x Chung 2017 11 BRCA RNAseq Single Cell RNAseq + IHC for B and T NA NA NA NA NA 2.2.1 Hoeck data 8 PBMC, RNAseq+flow cytometry load(&quot;../data/hoeck/HoekPBMC_mixture.RData&quot;) hoeck_mixture = mix.mat load(&quot;../data/hoeck/HoekPBMC_gtruth.RData&quot;) hoeck_ref = RefData 2.2.2 Schelker data Load the data and merge replicates ovarian_bulk_replicates = read_xls(&quot;../data/single_cell_schelker/ascites_bulk_samples.xls&quot;) samples = list(&quot;7873M&quot;=c(&quot;ascites_7873_1&quot;, &quot;ascites_7873_2&quot;), &quot;7882M&quot;=c(&quot;ascites_7882_1&quot;, &quot;ascites_7882_2&quot;), &quot;7892M&quot;=c(&quot;ascites_7892_1&quot;, &quot;ascites_7892_2&quot;)) ovarian_bulk = lapply(samples, function(cols) { apply(ovarian_bulk_replicates[,cols], 1, mean) }) %&gt;% bind_cols() ovarian_bulk %&lt;&gt;% mutate(gene_symbol = ovarian_bulk_replicates$Row) ovarian_bulk_mat = ovarian_bulk %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;gene_symbol&quot;) %&gt;% as.matrix() Load the ‘ground truth’ true_cell_count = pData(single_cell_schelker2) %&gt;% filter(source == &quot;ascites&quot;, donor %in% colnames(ovarian_bulk)) %&gt;% group_by(donor, cell_type) %&gt;% count() %&gt;% rename(cell_count=n) %&gt;% group_by(donor) %&gt;% mutate(true_fraction=cell_count/sum(cell_count)) %&gt;% arrange(cell_type, donor) total_cells = true_cell_count %&gt;% group_by(donor) %&gt;% summarise(sum(cell_count)) total_cells ## # A tibble: 3 x 2 ## donor `sum(cell_count)` ## &lt;chr&gt; &lt;int&gt; ## 1 7873M 864 ## 2 7882M 902 ## 3 7892M 773 true_cell_count ## # A tibble: 25 x 4 ## # Groups: donor [3] ## donor cell_type cell_count true_fraction ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 7873M B cells 5 0.00579 ## 2 7882M B cells 4 0.00443 ## 3 7892M B cells 5 0.00647 ## 4 7873M Cancer associated fibroblasts 9 0.0104 ## 5 7882M Cancer associated fibroblasts 11 0.0122 ## 6 7892M Cancer associated fibroblasts 16 0.0207 ## 7 7873M CD4+ T cells 29 0.0336 ## 8 7882M CD4+ T cells 137 0.152 ## 9 7892M CD4+ T cells 100 0.129 ## 10 7873M CD8+ T cells 4 0.00463 ## # ... with 15 more rows schelker_ref = true_cell_count %&gt;% select(sample=donor, cell_type, true_fraction) 2.2.3 Racle data ensg_hgnc = read_tsv(&quot;../data/ensemble_hgnc.txt&quot;) %&gt;% rename(gene_id = `Gene stable ID`, hgnc_symbol=`HGNC symbol`) ## Parsed with column specification: ## cols( ## `Gene stable ID` = col_character(), ## `HGNC symbol` = col_character() ## ) racle_cyto = read_excel(&quot;../data/racle/racle2017_flow_cytometry.xlsx&quot;) racle_files = list.files(&quot;../data/racle/GSE93722_RAW/&quot;, full.names = TRUE) racle_identifiers = str_extract(racle_files, &quot;LAU\\\\d+&quot;) racle_expression_raw = lapply(list.files(&quot;../data/racle/GSE93722_RAW/&quot;, full.names = TRUE), read_tsv) ## Parsed with column specification: ## cols( ## gene_id = col_character(), ## `transcript_id(s)` = col_character(), ## length = col_double(), ## effective_length = col_double(), ## expected_count = col_double(), ## TPM = col_double(), ## FPKM = col_double() ## ) ## Parsed with column specification: ## cols( ## gene_id = col_character(), ## `transcript_id(s)` = col_character(), ## length = col_double(), ## effective_length = col_double(), ## expected_count = col_double(), ## TPM = col_double(), ## FPKM = col_double() ## ) ## Parsed with column specification: ## cols( ## gene_id = col_character(), ## `transcript_id(s)` = col_character(), ## length = col_double(), ## effective_length = col_double(), ## expected_count = col_double(), ## TPM = col_double(), ## FPKM = col_double() ## ) ## Parsed with column specification: ## cols( ## gene_id = col_character(), ## `transcript_id(s)` = col_character(), ## length = col_double(), ## effective_length = col_double(), ## expected_count = col_double(), ## TPM = col_double(), ## FPKM = col_double() ## ) gene_ids = racle_expression_raw[[1]]$gene_id racle_tpm = sapply(racle_expression_raw, function(df) {pull(df, &quot;TPM&quot;)}) %&gt;% as.tibble() colnames(racle_tpm) = racle_identifiers racle_tpm$gene_id = gene_ids racle_expression = racle_tpm %&gt;% inner_join(ensg_hgnc) %&gt;% filter(!is.na(hgnc_symbol)) %&gt;% select(-gene_id) %&gt;% group_by(hgnc_symbol) %&gt;% summarise_all(sum) ## Joining, by = &quot;gene_id&quot; References "],
["validitiy-of-single-cell-rna-seq-as-reference.html", "3 Validitiy of single cell RNA-seq as reference 3.1 Validity of single cell sequencing for counting immune cells 3.2 Validity of simulated bulk tissues from single cell sequencing data", " 3 Validitiy of single cell RNA-seq as reference 3.1 Validity of single cell sequencing for counting immune cells Schelker et al have shown that measurements from single cell sequencing are highly consistent with flow cytometry. 3.2 Validity of simulated bulk tissues from single cell sequencing data We use simulated samples from single cell gene expression data. Does this approach make sense after all? We have 3 samples of single cell samples matched to bulk RNA sequencing. To test, we try: * correlation of the simulated gene expression with the measured bulk gene expression. * correlation of the predicted fractions with all methods on bulk vs. simulated tissue. ovarian_bulk_replicates = read_xls(&quot;../data/single_cell_schelker/ascites_bulk_samples.xls&quot;) samples = list(&quot;7873M&quot;=c(&quot;ascites_7873_1&quot;, &quot;ascites_7873_2&quot;), &quot;7882M&quot;=c(&quot;ascites_7882_1&quot;, &quot;ascites_7882_2&quot;), &quot;7892M&quot;=c(&quot;ascites_7892_1&quot;, &quot;ascites_7892_2&quot;)) ovarian_bulk = lapply(samples, function(cols) { apply(ovarian_bulk_replicates[,cols], 1, mean) }) %&gt;% bind_cols() ovarian_bulk %&lt;&gt;% mutate(gene_symbol = ovarian_bulk_replicates$Row) ovarian_bulk_mat = ovarian_bulk %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;gene_symbol&quot;) %&gt;% as.matrix() Load the ‘ground truth’ true_cell_count = pData(single_cell_schelker2) %&gt;% filter(source == &quot;ascites&quot;, donor %in% colnames(ovarian_bulk)) %&gt;% group_by(donor, cell_type) %&gt;% count() %&gt;% rename(cell_count=n) %&gt;% group_by(donor) %&gt;% mutate(true_fraction=cell_count/sum(cell_count)) %&gt;% arrange(cell_type, donor) total_cells = true_cell_count %&gt;% group_by(donor) %&gt;% summarise(sum(cell_count)) total_cells ## # A tibble: 3 x 2 ## donor `sum(cell_count)` ## &lt;chr&gt; &lt;int&gt; ## 1 7873M 864 ## 2 7882M 902 ## 3 7892M 773 true_cell_count ## # A tibble: 25 x 4 ## # Groups: donor [3] ## donor cell_type cell_count true_fraction ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 7873M B cells 5 0.00579 ## 2 7882M B cells 4 0.00443 ## 3 7892M B cells 5 0.00647 ## 4 7873M Cancer associated fibroblasts 9 0.0104 ## 5 7882M Cancer associated fibroblasts 11 0.0122 ## 6 7892M Cancer associated fibroblasts 16 0.0207 ## 7 7873M CD4+ T cells 29 0.0336 ## 8 7882M CD4+ T cells 137 0.152 ## 9 7892M CD4+ T cells 100 0.129 ## 10 7873M CD8+ T cells 4 0.00463 ## # ... with 15 more rows 3.2.1 Compare simululated samplese to bulk samples randomized: cell_fractions = true_cell_count %&gt;% select(donor, cell_type, true_fraction) %&gt;% complete(donor, cell_type=available_cell_types) %&gt;% mutate(true_fraction=ifelse(is.na(true_fraction), 0, true_fraction)) %&gt;% spread(cell_type, true_fraction) %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;donor&quot;) bulk_eset_rand = make_bulk_eset(eset=single_cell_schelker2, cell_fractions = cell_fractions, n_cells=500) bulk_rand = eset_to_matrix(bulk_eset_rand, column = &quot;gene_symbol&quot;) colnames(bulk_rand) = names(samples) summing up all cells: bulk_sum = sapply(names(samples), function(donor) { ind = pData(single_cell_schelker2)$donor == donor # apply(exprs(single_cell_schelker2)[,ind], 1, function(x){quantile(x, c(.98))}) apply(exprs(single_cell_schelker2)[,ind], 1, sum) }) genes = intersect(rownames(bulk_sum), ovarian_bulk$gene_symbol) expr_all = bind_rows( ovarian_bulk %&gt;% mutate(source=&quot;bulk&quot;), bulk_rand %&gt;% as_tibble(rownames=&quot;gene_symbol&quot;) %&gt;% mutate(source=&quot;rand&quot;), bulk_sum %&gt;% as_tibble(rownames=&quot;gene_symbol&quot;) %&gt;% mutate(source=&quot;sum&quot;) ) %&gt;% filter(gene_symbol %in% genes) %&gt;% gather(sample, tpm, -gene_symbol, -source) %&gt;% spread(source, tpm) expr_all %&gt;% mutate(bulk=log2(bulk+1), sum=log2(sum+1)) %&gt;% ggplot(aes(x=bulk, y=sum)) + geom_point() + stat_cor() + facet_wrap(~sample) + geom_abline(slope=1, intercept = 0, col=&quot;red&quot;) 3.2.2 Compare the predicted fractions all_results_bulk = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(ovarian_bulk_mat, method) %&gt;% mutate(method=method) %&gt;% mutate(source=&quot;bulk&quot;) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 152/153 (99.35%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## [1] &quot;Num. of genes: 10781&quot; ## Estimating ssGSEA scores for 489 gene sets. ## | | | 0%Using parallel with 4 cores ## | |====================== | 33% | |=========================================== | 67% | |=================================================================| 100% all_results_simulated = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(bulk_sum, method) %&gt;% mutate(method=method) %&gt;% mutate(source=&quot;sum&quot;) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 140/153 (91.5%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## [1] &quot;Num. of genes: 10462&quot; ## Warning in .local(expr, gset.idx.list, ...): 1genes with constant ## expression values throuhgout the samples. ## Estimating ssGSEA scores for 489 gene sets. ## | | | 0%Using parallel with 4 cores ## | |====================== | 33% | |=========================================== | 67% | |=================================================================| 100% all_results = bind_rows(all_results_bulk, all_results_simulated) %&gt;% gather(donor, fraction, -cell_type, -source, -method) %&gt;% spread(source, fraction) all_results %&gt;% ggplot(aes(x = bulk, y=sum)) + geom_point(aes(colour=cell_type)) + facet_wrap(~method, scales=&quot;free&quot;) + stat_cor() "],
["spillover-analysis.html", "4 Spillover analysis 4.1 Run the deconvolution 4.2 Results", " 4 Spillover analysis In this chapter, we will use single cell data from (Schelker et al. 2017) to create simulated pure immune cell RNA samples (and pure RNA samples from other studies (tbd)). We will then evaluate, if predictions of a certain immune cell type correlate with another. immune_cell_samples = read_tsv(&quot;../data/immune_cell_reference_profiles/immune_cell_reference_tidy.tsv&quot;) sample_description = immune_cell_samples %&gt;% select(sample, CellType, Study) %&gt;% distinct() expr = immune_cell_samples %&gt;% select(sample, hgnc_id, TPM) %&gt;% group_by(sample, hgnc_id) %&gt;% summarise(TPM = sum(TPM)) %&gt;% spread(sample, TPM) expr_mat = expr %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;hgnc_id&quot;) %&gt;% as.matrix() %&gt;% .[, sample_description$sample] 4.1 Run the deconvolution We first run all methods that are integrated in the immune_deconvolution_methods are package automatically in a loop. all_results = lapply(immunedeconv::deconvolution_methods, function(method) { print(sprintf(&quot;Running %s...&quot;, method)) deconvolute(expr_mat, method) %&gt;% mutate(method=method) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): The optimization didn&#39;t fully converge for some samples: ## SRR1551070; SRR1740062; SRR452331; SRR1551055; SRR1551048; SRR1740046; SRR1551073; SRR1551059; SRR1740050; SRR1740078; SRR1551057; ERR431583; ERR431606; ERR431601 ## - check fit.gof for the convergeCode and convergeMessage ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. 4.1.1 run TIMER TIMER (B. Li et al. 2016) is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. immunedeconv::export_for_timer(expr_mat, &quot;../results/timer_input_spillover.tsv&quot;) res_timer = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_spillover.csv&quot;) %&gt;% mutate(method=&quot;timer&quot;) 4.2 Results Here, we map the results back to the “gold standard”. We aggregate the results of the different methods into a single table and clean it up for further processing. gold_standard = sample_description %&gt;% select(sample, true_cell_type=CellType) all_results2 = all_results %&gt;% c(list(res_timer)) # # summarise cell_types from the method that only map to a single cell_type in the reference dataset (namely monocytes and macrophages) all_results3 = lapply(all_results2, function(res) { res %&gt;% map_results_to_dataset(&quot;quantiseq_reference&quot;) %&gt;% group_by(method, quantiseq_reference) %&gt;% summarise_all(funs(sum)) }) all_results_tidy = all_results3 %&gt;% bind_rows() %&gt;% rename(cell_type = quantiseq_reference) %&gt;% gather(sample, estimate, -cell_type, -method) %&gt;% inner_join(gold_standard, by=&quot;sample&quot;) %&gt;% group_by(method, sample) %&gt;% mutate(estimate_scaled = (estimate - min(estimate)) / (max(estimate) - min(estimate)), # add scaled estimate estimate_fraction = estimate/sum(estimate)) %&gt;% mutate(signal = ifelse(sum(cell_type==true_cell_type)==1,estimate_fraction[cell_type==true_cell_type],NA), # add signal and noise noise = sum(estimate_fraction[cell_type!=true_cell_type]), abs_noise = sum(estimate[cell_type!=true_cell_type])) %&gt;% ungroup() %&gt;% arrange(method, cell_type, sample) all_results_tidy %&gt;% ggplot(aes(x=cell_type, y=true_cell_type)) + geom_tile(aes(fill=estimate_fraction)) + facet_wrap(~method) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(&quot;Spillover by Method&quot;) + theme(panel.background=element_rect(fill=&quot;lightgrey&quot;)) all_results_tidy %&gt;% ggplot(aes(x=cell_type, y=method)) + geom_tile(aes(fill=estimate_fraction)) + facet_wrap(~true_cell_type) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle(&quot;Spillover by cell type&quot;) + theme(panel.background=element_rect(fill=&quot;lightgrey&quot;)) 4.2.1 Calculate signal to noise ratio for each cell type all_results_tidy %&gt;% select(method, true_cell_type, signal, noise) %&gt;% distinct() %&gt;% mutate(signal_to_noise = signal/(signal+noise)) %&gt;% ggplot(aes(x=method, y=signal_to_noise)) + geom_boxplot(aes(fill=method), position = &quot;dodge&quot;) + facet_wrap(~true_cell_type) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_fill_manual(values=color_scales$methods) ## Warning: Removed 25 rows containing non-finite values (stat_boxplot). all_results_tidy %&gt;% select(method, true_cell_type, abs_noise) %&gt;% distinct() %&gt;% filter(method %in% c(&quot;xcell&quot;, &quot;quantiseq&quot;, &quot;epic&quot;, &quot;cibersort&quot;)) %&gt;% ggplot(aes(x=method, y=abs_noise)) + geom_boxplot(aes(fill=method), position=&quot;dodge&quot;) + facet_wrap(~true_cell_type) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_fill_manual(values=color_scales$methods) References "],
["mixing-study.html", "5 Mixing study 5.1 Average fraction of tumour cells 5.2 Create simulated bulk tissues 5.3 Run the deconvolution 5.4 Results", " 5 Mixing study In this chapter, we will use single cell data from (Schelker et al. 2017) to create simulated bulk RNAseq samples of which we know the true cell proportions. We futher use these samples to benchmark the performance of different recently published immune deconvolution tools. 5.1 Average fraction of tumour cells To obtain representatitive simulated samples, we are interested in the average fraction of tumour cells vs immune cells in a mixture. cell_type_table = pData(single_cell_schelker2) %&gt;% filter(source %in% c(&quot;melanoma&quot;, &quot;ascites&quot;)) %&gt;% mutate(sample=paste(source, donor, sep=&quot;_&quot;)) %&gt;% group_by(source, sample, cell_type) %&gt;% summarise(n=n()) %&gt;% mutate(freq=n/sum(n)) ggplot(cell_type_table, aes(x=sample, y=freq)) + geom_bar(aes(fill=cell_type), stat=&quot;identity&quot;) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_fill_manual(values=color_scales$cell_types) cancer_cells = cell_type_table %&gt;% filter(cell_type %in% c(&quot;Melanoma cells&quot;, &quot;Ovarian carcinoma cells&quot;)) cancer_cell_param = MASS::fitdistr(cancer_cells$freq, &quot;normal&quot;) 5.2 Create simulated bulk tissues The fractions of a sample are randomly assigned in the following procedure: Draw a random tumour cell content from the distribution fitted above The first half of the samples will use melanoma cells, the second half ovarian cancer cells. Assign the remaining fraction (=not cancer cells) randomly to the remaining cell types (B cells, CD8+ T cells, Melanoma cells, CD4+ T cells, Macrophages/Monocytes, regulatory T cells, Cancer associated fibroblasts, Dendritic cells, Endothelial cells, Natural killer cells, Ovarian carcinoma cells) set.seed(42) cancer_cells = c(&quot;Melanoma cells&quot;, &quot;Ovarian carcinoma cells&quot;) immune_cells = available_cell_types[!(available_cell_types %in% cancer_cells)] is_melanoma = c(rep(TRUE, 50), rep(FALSE, 50)) cell_fractions = lapply(is_melanoma, function(melanoma) { cancer_fraction = rnorm(1, mean=cancer_cell_param$estimate[1], sd=cancer_cell_param$estimate[2]) cancer_fraction = ifelse(cancer_fraction &lt; 0, 0, cancer_fraction) cancer_fraction = ifelse(cancer_fraction &gt; 1, 1, cancer_fraction) # associate fraction randomly ot Melanoma or Ovarian if(melanoma) { cancer_fractions = list(cancer_fraction, 0) } else { cancer_fractions = list(0, cancer_fraction) } names(cancer_fractions) = cancer_cells # compute random fractions for other cells remaining_fraction = 1 - cancer_fraction rnd = sample(0:100, length(immune_cells), TRUE) tmp_fractions = (remaining_fraction * rnd) / sum(rnd) names(tmp_fractions) = immune_cells c(cancer_fractions, tmp_fractions) }) %&gt;% bind_rows() testthat::test_that(&quot;all fractions sum up to 1&quot;, expect_equal(apply(cell_fractions, 1, sum), rep(1, 100))) set.seed(42) bulk_eset = make_bulk_eset(eset=single_cell_schelker2, cell_fractions = cell_fractions, n_cells=500) 5.3 Run the deconvolution We first run all methods that are integrated in the immune_deconvolution_methods are package automatically in a loop. all_results = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(bulk_eset, method, column=&quot;gene_symbol&quot;) %&gt;% mutate(method=method) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): The optimization didn&#39;t fully converge for some samples: ## value4; value5; value7; value34; value51; value62; value64; value66; value78 ## - check fit.gof for the convergeCode and convergeMessage ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 140/153 (91.5%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## [1] &quot;Num. of genes: 10462&quot; ## Estimating ssGSEA scores for 489 gene sets. ## | | | 0%Using parallel with 4 cores ## | |= | 1% | |= | 2% | |== | 3% | |=== | 4% | |=== | 5% | |==== | 6% | |===== | 7% | |===== | 8% | |====== | 9% | |====== | 10% | |======= | 11% | |======== | 12% | |======== | 13% | |========= | 14% | |========== | 15% | |========== | 16% | |=========== | 17% | |============ | 18% | |============ | 19% | |============= | 20% | |============== | 21% | |============== | 22% | |=============== | 23% | |================ | 24% | |================ | 25% | |================= | 26% | |================== | 27% | |================== | 28% | |=================== | 29% | |==================== | 30% | |==================== | 31% | |===================== | 32% | |===================== | 33% | |====================== | 34% | |======================= | 35% | |======================= | 36% | |======================== | 37% | |========================= | 38% | |========================= | 39% | |========================== | 40% | |=========================== | 41% | |=========================== | 42% | |============================ | 43% | |============================= | 44% | |============================= | 45% | |============================== | 46% | |=============================== | 47% | |=============================== | 48% | |================================ | 49% | |================================ | 50% | |================================= | 51% | |================================== | 52% | |================================== | 53% | |=================================== | 54% | |==================================== | 55% | |==================================== | 56% | |===================================== | 57% | |====================================== | 58% | |====================================== | 59% | |======================================= | 60% | |======================================== | 61% | |======================================== | 62% | |========================================= | 63% | |========================================== | 64% | |========================================== | 65% | |=========================================== | 66% | |============================================ | 67% | |============================================ | 68% | |============================================= | 69% | |============================================== | 70% | |============================================== | 71% | |=============================================== | 72% | |=============================================== | 73% | |================================================ | 74% | |================================================= | 75% | |================================================= | 76% | |================================================== | 77% | |=================================================== | 78% | |=================================================== | 79% | |==================================================== | 80% | |===================================================== | 81% | |===================================================== | 82% | |====================================================== | 83% | |======================================================= | 84% | |======================================================= | 85% | |======================================================== | 86% | |========================================================= | 87% | |========================================================= | 88% | |========================================================== | 89% | |========================================================== | 90% | |=========================================================== | 91% | |============================================================ | 92% | |============================================================ | 93% | |============================================================= | 94% | |============================================================== | 95% | |============================================================== | 96% | |=============================================================== | 97% | |================================================================ | 98% | |================================================================ | 99% | |=================================================================| 100% 5.3.1 run TIMER TIMER (B. Li et al. 2016) is only available as a web resource. Moreover, the algorithm is adapted for each cancer type, so that we have to choose the corresponding option (Melanoma/Ovarian) when running the algorithm. We therefore export the data required to run the algorithm and re-import the results obtained from the web-tool. eset_mat = eset_to_matrix(bulk_eset, &quot;gene_symbol&quot;) immunedeconv::export_for_timer(eset_mat[,is_melanoma], path=&quot;../results/timer_input_melanoma.tsv&quot;) immunedeconv::export_for_timer(eset_mat[,!is_melanoma], path=&quot;../results/timer_input_ovarian.tsv&quot;) res_timer_melanoma = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_melanoma.csv&quot;) ## Parsed with column specification: ## cols( ## sampleID = col_character(), ## B_cell = col_double(), ## T_cell.CD4 = col_double(), ## T_cell.CD8 = col_double(), ## Neutrophil = col_double(), ## Macrophage = col_double(), ## DC = col_double() ## ) res_timer_ovarian = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_ovarian.csv&quot;) ## Parsed with column specification: ## cols( ## sampleID = col_character(), ## B_cell = col_double(), ## T_cell.CD4 = col_double(), ## T_cell.CD8 = col_double(), ## Neutrophil = col_double(), ## Macrophage = col_double(), ## DC = col_double() ## ) res_timer = inner_join(res_timer_melanoma, res_timer_ovarian, by=&quot;cell_type&quot;) %&gt;% mutate(method=&quot;timer&quot;) abs_methods = c(&quot;cibersort_abs&quot;, &quot;epic&quot;, &quot;quantiseq&quot;, &quot;xcell&quot;) 5.4 Results Here, we map the results back to the “gold standard”. We aggregate the results of the different methods into a single table and clean it up for further processing. all_results2 = all_results %&gt;% c(list(res_timer)) # summarise cell_types from the method that only map to a single cell_type in the reference dataset (namely monocytes and macrophages) all_results3 = lapply(all_results2, function(res) { res %&gt;% map_results_to_dataset(&quot;single_cell_schelker&quot;) %&gt;% group_by(method, single_cell_schelker) %&gt;% summarise_all(funs(sum)) }) all_results_tidy = all_results3 %&gt;% bind_rows() %&gt;% rename(cell_type = single_cell_schelker) %&gt;% gather(sample, estimate, -cell_type, -method) %&gt;% arrange(method, cell_type, sample) gold_standard = pData(bulk_eset) %&gt;% rownames_to_column(&quot;sample&quot;) %&gt;% gather(cell_type, true_fraction, -sample) 5.4.1 Calculate “Other cells” for all absolute methods other_cells_estimates = all_results_tidy %&gt;% filter(method %in% abs_methods) %&gt;% group_by(method, sample) %&gt;% summarise(cell_type=&quot;Other&quot;, estimate=max(0, 1-sum(estimate))) other_cells_true_fractions = gold_standard %&gt;% inner_join(all_results_tidy %&gt;% select(method, sample) %&gt;% distinct(), by=c(&quot;sample&quot;)) %&gt;% anti_join(all_results_tidy, by=c(&quot;sample&quot;, &quot;cell_type&quot;, &quot;method&quot;)) %&gt;% group_by(method, sample) %&gt;% summarise(cell_type=&quot;Other&quot;, true_fraction=sum(true_fraction)) all_results_tidy2 = bind_rows(all_results_tidy, other_cells_estimates) # we need to add the methods (full join) to each cell type as # the &quot;Other&quot; fractions are method specific # (all cell types that are not predicted by the method) gold_standard2 = gold_standard %&gt;% crossing(method=unique(all_results_tidy$method)) %&gt;% bind_rows(other_cells_true_fractions) results_with_gold_standard = all_results_tidy2 %&gt;% inner_join(gold_standard2, by=c(&quot;sample&quot;, &quot;cell_type&quot;, &quot;method&quot;)) 5.4.2 Correlation plots results_with_gold_standard %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + facet_grid(method ~ cell_type, scales=&quot;free&quot;) + geom_point() + stat_smooth(aes(color=method), method=&quot;lm&quot;) + scale_color_manual(values=color_scales$methods) + scale_x_continuous(breaks=c(.2, .5)) 5.4.3 Calculate correlations for each method and cell type make_cor = function(estimate, true_fraction) { test_res = cor.test(estimate, true_fraction, method=&quot;pearson&quot;) data.frame( pearson=test_res$estimate, conf_int_lower=test_res$conf.int[1], conf_int_upper=test_res$conf.int[2] ) } correlations = results_with_gold_standard %&gt;% group_by(cell_type, method) %&gt;% do(make_cor(.$estimate, .$true_fraction)) correlations %&gt;% ggplot(aes(x=method, y=pearson)) + geom_bar(aes(fill=method), stat=&quot;identity&quot;) + geom_errorbar(aes(ymin=conf_int_lower, ymax=conf_int_upper), width=.2) + facet_wrap(~cell_type, nrow=2) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1), legend.position=&quot;top&quot;) + scale_fill_manual(values=color_scales$methods) 5.4.4 Absolute error for all qualifying methods results_with_gold_standard %&gt;% filter(method %in% abs_methods) %&gt;% mutate(error=abs(estimate-true_fraction)) %&gt;% mutate(square_error=error^2) %&gt;% ggplot(aes(x=method, y=square_error)) + facet_wrap(~cell_type, nrow=1) + geom_boxplot(aes(fill=method), width=1, position=&quot;dodge&quot;) + theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_fill_manual(values=color_scales$methods) References "],
["validation-with-real-data.html", "6 Validation with real data 6.1 Run the deconvolution", " 6 Validation with real data We the curated datasets with gold standard as an additional validation on top of the mixing study. racle_bulk_mat = racle_expression %&gt;% as.data.frame() %&gt;% column_to_rownames(&quot;hgnc_symbol&quot;) %&gt;% as.matrix() hoeck_bulk_mat = hoeck_mixture # ovarian_bulk_mat 6.1 Run the deconvolution We first run all methods that are integrated in the immune_deconvolution_methods are package automatically in a loop. all_results_racle = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(racle_bulk_mat, method) %&gt;% mutate(method=method) %&gt;% map_results_to_dataset(&quot;racle&quot;) %&gt;% group_by(method, racle) %&gt;% summarise_all(funs(sum)) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 148/153 (96.73%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## [1] &quot;Num. of genes: 10564&quot; ## Estimating ssGSEA scores for 489 gene sets. ## | | | 0%Using parallel with 4 cores ## | |================ | 25% | |================================ | 50% | |================================================= | 75% | |=================================================================| 100% all_results_hoeck = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(hoeck_bulk_mat, method) %&gt;% mutate(method=method) %&gt;% map_results_to_dataset(&quot;hoeck&quot;) %&gt;% group_by(method, hoeck) %&gt;% summarise_all(funs(sum)) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 153/153 (100%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## [1] &quot;Num. of genes: 10733&quot; ## Estimating ssGSEA scores for 489 gene sets. ## | | | 0%Using parallel with 4 cores ## | |======== | 12% | |================ | 25% | |======================== | 38% | |================================ | 50% | |========================================= | 62% | |================================================= | 75% | |========================================================= | 88% | |=================================================================| 100% all_results_schelker = lapply(immunedeconv::deconvolution_methods, function(method) { deconvolute(ovarian_bulk_mat, method) %&gt;% mutate(method=method) %&gt;% map_results_to_dataset(&quot;single_cell_schelker&quot;) %&gt;% group_by(method, single_cell_schelker) %&gt;% summarise_all(funs(sum)) }) ## Warning in EPIC::EPIC(bulk = gene_expression_matrix, ...): mRNA_cell value ## unknown for some cell types: CAFs, Endothelial - using the default value of ## 0.4 for these but this might bias the true cell proportions from all cell ## types. ## ## Running quanTIseq deconvolution module ## Gene expression normalization and re-annotation (arrays: FALSE) ## Removing 17 noisy genes ## Signature genes found in data set: 152/153 (99.35%) ## Mixture deconvolution (method: lsei) ## Deconvolution sucessful! ## [1] &quot;Num. of genes: 10781&quot; ## Estimating ssGSEA scores for 489 gene sets. ## | | | 0%Using parallel with 4 cores ## | |====================== | 33% | |=========================================== | 67% | |=================================================================| 100% # immunedeconv::export_for_timer(ovarian_bulk_mat, path=&quot;../results/timer_input_ovarian_bulk.tsv&quot;) # # res_timer = immunedeconv::import_from_timer(&quot;../data/timer/timer_result_ovarian_bulk.csv&quot;) %&gt;% # mutate(method=&quot;timer&quot;) hoeck_ref2 = hoeck_ref %&gt;% as_tibble(rownames=&quot;sample&quot;) %&gt;% gather(cell_type, true_fraction, -sample) hoeck2 = bind_rows(all_results_hoeck) %&gt;% gather(sample, estimate, -method, -hoeck) %&gt;% mutate(dataset=&quot;hoeck&quot;) %&gt;% rename(cell_type=hoeck) %&gt;% inner_join(hoeck_ref2) ## Joining, by = c(&quot;cell_type&quot;, &quot;sample&quot;) racle_ref2 = racle_cyto %&gt;% rename(sample=`donor ID`) %&gt;% gather(cell_type, true_fraction, -sample) %&gt;% mutate(true_fraction=true_fraction/100) racle2 = bind_rows(all_results_racle) %&gt;% gather(sample, estimate, -method, -racle) %&gt;% mutate(dataset=&quot;racle&quot;) %&gt;% rename(cell_type=racle) %&gt;% inner_join(racle_ref2) ## Joining, by = c(&quot;cell_type&quot;, &quot;sample&quot;) schelker_ref2 = schelker_ref schelker2 = bind_rows(all_results_schelker) %&gt;% gather(sample, estimate, -method, -single_cell_schelker) %&gt;% mutate(dataset=&quot;single_cell_schelker&quot;) %&gt;% rename(cell_type=single_cell_schelker) %&gt;% inner_join(schelker_ref2) ## Joining, by = c(&quot;cell_type&quot;, &quot;sample&quot;) all_results_tidy_val = bind_rows(hoeck2, racle2, schelker2) %&gt;% ungroup() all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;B cells&quot;, &quot;Bcells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;B cells&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;Dendritic cells&quot;, &quot;DC&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;Dendritic cells&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;CD8+ T cells&quot;, &quot;CD8 T cells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;CD8 T&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;CD4+ T cells&quot;, &quot;CD4 T cells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;CD4 T&quot;) all_results_tidy_val %&gt;% filter(cell_type %in% c(&quot;Natural killer cells&quot;, &quot;NK&quot;, &quot;NK cells&quot;)) %&gt;% ggplot(aes(x=true_fraction, y=estimate)) + geom_point(aes(color=method, shape=dataset)) + scale_color_manual(values=color_scales$methods) + facet_wrap(~method, scales = &quot;free&quot;) + stat_cor() + ggtitle(&quot;NK&quot;) "],
["conclusions.html", "7 Conclusions", " 7 Conclusions Not sure if the methodology is valid after all? Anyway, conclusions: * Some cell types (CTL) are easier to detect that others (DC) * The deconvolution methodology is not the bottleneck, it’s the availability of reliable signatures "],
["materials-and-methods.html", "8 Materials and Methods 8.1 Data acquisition 8.2 Validation datasets (Flow cytometry, scRNAseq, Imageing + matched RNA seq)", " 8 Materials and Methods 8.1 Data acquisition For the single cell dataset by Schelker et al. (2017), we obtained the MATLAB source code deposited on figshare and used it to re-produced the dataset. The final dataset was exported to csv format in order to continue the main analysis in R. We obtained the 3 matched ovarian cancer bulk RNA samples from Schelker et al. (2017) (personal communication). 8.2 Validation datasets (Flow cytometry, scRNAseq, Imageing + matched RNA seq) Describe how the datasets were obtained References "],
["references.html", "9 References", " 9 References "]
]
